# Планирование: setTimeout и setInterval

Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».
Для этого существуют два метода:
- `setTimeout` позволяет вызвать функцию один раз через определённый интервал времени.
- `setInterval` позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.\
Эти методы не являются частью спецификации JavaScript. Но большинство сред выполнения JS-кода имеют внутренний планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех браузерах и Node.js.
- Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.
- setTimeout ожидает ссылку на функцию.
- Вызов `setTimeout` возвращает «идентификатор таймера» `timerId`, который можно использовать для отмены дальнейшего выполнения через `clearTimeout`
```js
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);
clearTimeout(timerId);
```

```js
function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
}
setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон
setTimeout("alert('Привет')", 1000);
```
## setInterval
```js
 let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
```
Вложенный setTimeout позволяет задать задержку между выполнениями более точно, чем setInterval.\
ВложенныйsetTimeout гарантирует фиксированную задержку (здесь 100 мс).
```js
/** вместо:
let timerId = setInterval(() => alert('tick'), 2000);
*/
let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);
```
(*) Сборка мусора и колбэк setTimeout/setInterval\
Когда функция передаётся в setInterval/setTimeout, на неё создаётся внутренняя ссылка и сохраняется в планировщике. Это предотвращает попадание функции в сборщик мусора, даже если на неё нет других ссылок.\
Для setInterval функция остаётся в памяти до тех пор, пока не будет вызван clearInterval.
```js
// функция остаётся в памяти до тех пор, пока планировщик обращается к ней
setTimeout(function() {...}, 100);
```
! Есть и побочный эффект. Функция ссылается на внешнее лексическое окружение, поэтому пока она существует, внешние переменные существуют тоже. Они могут занимать больше памяти, чем сама функция. Поэтому, если регулярный вызов функции больше не нужен, то лучше отменить его, даже если функция очень маленькая.

(*) setTimeout с нулевой задержкой

Особый вариант использования: `setTimeout(func, 0)` или просто `setTimeout(func)`.
Это планирует вызов `func` настолько быстро, насколько это возможно. Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.\
Например, этот код выводит «Привет» и затем сразу «Мир»:
```js
setTimeout(() => alert("Мир"));
alert("Привет");
```
(*) Минимальная задержка вложенных таймеров в браузере\
В браузере есть ограничение на то, как часто внутренние счётчики могут выполняться.\
В стандарте HTML5 говорится: «после пяти вложенных таймеров интервал должен составлять не менее четырёх миллисекунд.».
```js
let start = Date.now();
let times = [];

setTimeout(function run() {
  times.push(Date.now() - start); // запоминаем задержку от предыдущего вызова

  if (start + 100 < Date.now()) alert(times); // показываем задержку через 100 мс
  else setTimeout(run); // если нужно ещё запланировать
});
// пример вывода:
// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100
```
[Первый таймер запускается сразу (как и указано в спецификации), а затем задержка вступает в игру, и мы видим 9, 15, 20, 24....\
Это ограничение существует давно, многие скрипты полагаются на него, поэтому оно сохраняется по историческим причинам.

Этого ограничения нет в серверном JavaScript. Там есть и другие способы планирования асинхронных задач. Например, setImmediate для Node.js. Так что это ограничение относится только к браузерам.]

! Обратим внимание, что все методы планирования не гарантируют точную задержку.ё
Таймер в браузере может замедляться по многим причинам:
- Перегружен процессор.
- Вкладка браузера в фоновом режиме.
- Работа ноутбука от аккумулятора.

# Декораторы и переадресация вызова, call/apply

JavaScript предоставляет исключительно гибкие возможности по работе с функциями: они могут быть переданы в другие функции, использованы как объекты, и сейчас мы рассмотрим, *как перенаправлять вызовы между ними и как их декорировать*

(*) Применение «func.call» для передачи контекста.\
Существует специальный встроенный метод функции `func.call(context, …args)`, который позволяет вызывать функцию, явно устанавливая this.\
Он запускает функцию func, используя первый аргумент как её контекст this, а последующие – как её аргументы.
```js
func.call(context, arg1, arg2, ...)
```
```js
function sayHi(phrase) {
  alert(phrase + ':' + this.name);
}
let user = { name: "John" };
let admin = { name: "Admin" };

// используем 'call' для передачи различных объектов в качестве 'this'
sayHi.call( user ); // John
sayHi.call( admin, "Hello" ); // Admin
```
Вместо `func.call(this, ...arguments)` мы могли бы написать `func.apply(this, arguments)`.
```js
func.apply(context, args);
```
Он выполняет `func`, устанавливая `this=context` и принимая в качестве списка аргументов псевдомассив `args`.\

! Единственная разница в синтаксисе между `call` и `apply` состоит в том, что `call` ожидает список аргументов, в то время как `apply` принимает псевдомассив.\
Есть только одна небольшая разница:
- Оператор расширения ... позволяет передавать перебираемый объект `args` в виде списка в `call`.
- А apply принимает только псевдомассив `args`.
```js
// Эти два вызова почти эквивалентны:
func.call(context, ...args); // передаёт массив как список с оператором расширения
func.apply(context, args);   // тот же эффект
```
! Передача всех аргументов вместе с контекстом другой функции называется «перенаправлением вызова» (call forwarding).!

Простейший вид такого перенаправления:
```js
let wrapper = function() {
  return func.apply(this, arguments);
};
```
(*) *Заимствование метода*

Мы берём (заимствуем) метод join из обычного массива [].join. И используем [].join.call, чтобы выполнить его в контексте arguments.
```js
function hash(args) {
  return args[0] + ',' + args[1];
}

function hash() {
  alert( [].join.call(arguments) ); // 1,2
}

hash(1, 2);
```
# Привязка контекста к функции

При передаче методов объекта в качестве колбэков, например для setTimeout, возникает известная проблема – потеря this.

```js
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};
setTimeout(user.sayHi, 1000); // Привет, undefined!

// Решение 1: сделать функцию-обёртку
setTimeout(function() {
  user.sayHi(); // Привет, Вася!
}, 1000);
// Или так
setTimeout(() => user.sayHi(), 1000); // Привет, Вася!
// ...в течение 1 секунды
user = { sayHi() { alert("Другой пользователь в 'setTimeout'!"); } };
// Решение 2: привязать контекст с помощью bind
```
Самый простой вариант решения – это обернуть вызов в анонимную функцию, создав замыкание.\
Теперь код работает корректно, так как объект user достаётся из замыкания, а затем вызывается его метод `sayHi`.\
? Но теперь в нашем коде появилась небольшая уязвимость.
[В переменную user можно записать другое значение? Тогда вызов неожиданно будет совсем не тот!]\
В современном JavaScript у функций есть встроенный метод bind, который позволяет зафиксировать this.\
[Результатом вызова `func.bind(context)` является особый «экзотический объект» (термин взят из спецификации), который вызывается как функция и прозрачно передаёт вызов в func, при этом устанавливая `this=context`.]
```js
// полный синтаксис будет представлен немного позже
let boundFunc = func.bind(context);
let bound = func.bind(context, [arg1], [arg2], ...);
```
```js
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};
function func() {
  alert(this.firstName);
}
let funcUser = func.bind(user);
funcUser(); // Вася

let sayHi = user.sayHi.bind(user); // (*)
sayHi(); // Привет, Вася!
setTimeout(sayHi, 1000); // Привет, Вас
```
[В строке (*) мы берём метод user.sayHi и привязываем его к user. Теперь sayHi – это «связанная» функция, которая может быть вызвана отдельно или передана в setTimeout (контекст всегда будет правильным).]

```js
for (let key in user) {
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}
/*
Некоторые JS-библиотеки предоставляют встроенные функции для удобной массовой привязки контекста, например _.bindAll(obj) в lodash. */
```
Следующаая функция позволяет привязать контекст this и начальные аргументы функции.
```js
function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10
```
Вызов mul.bind(null, 2) создаёт новую функцию double, которая передаёт вызов mul, фиксируя null как контекст, и 2 – как первый аргумент. Следующие аргументы передаются как есть.

Это называется частичное применение – мы создаём новую функцию, фиксируя некоторые из существующих параметров.\
Также есть готовый вариант _.partial из библиотеки lodash.
```js
```


```js
```
