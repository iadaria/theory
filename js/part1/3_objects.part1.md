# Объекты

Как мы знаем из главы Типы данных, в JavaScript существует 8 типов данных. Семь из них называются «примитивными», так как содержат только одно значение (будь то строка, число или что-то другое).
Объекты же используются для хранения коллекций различных значений и более сложных сущностей. 
Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
В JavaScript есть много других типов объектов:
- Array для хранения упорядоченных коллекций данных,
- Date для хранения информации о дате и времени,
- Error для хранения информации об ошибке.

Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств.Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно.
```js
let user = new Object(); // синтаксис "конструктор объекта"
const user = {
  age: 1, //Это называется «висячая запятая». 
  "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
};  // синтаксис "литерал объекта"

user.isAdmin = true;
delete user.age;

// присваивание значения свойству
user["likes birds"] = true;

let key = "likes birds";
// то же самое, что и user["likes birds"] = true;
user[key] = true;

```
Обычно используют вариант с фигурными скобками {...}. Такое объявление называют литералом объекта или литеральной нотацией.
Значение может быть любого типа. Давайте добавим свойство с логическим значением.
Объект, объявленный через const, может быть изменён.
Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.
Свойства могут быть ключи зарезервированные слова.
Если использовать число 0 в качестве ключа, то оно превратится в строку "0":
```js
// эти имена свойств допустимы
let obj = {
  for: 1,
  let: 2,
  return: 3
};

let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};
```
Есть небольшой подводный камень, связанный со специальным свойством __proto__. Мы не можем установить его в необъектное значение:
let obj = {};
obj.__proto__ = 5; // присвоим число
alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали.

* При обращении к свойству, которого нет, возвращается undefined.
Также существует специальный оператор "in" для проверки существования свойства в объекте.
* Обратите внимание, что слева от оператора in должно быть имя свойства. Обычно это строка в кавычках.
Это когда свойство существует, но содержит значение undefined
```js
let user = {};
alert( user.noSuchProperty === undefined ); // true означает "свойства нет"

let obj = {
  test: undefined
};

alert( obj.test ); //  выведет undefined, значит свойство не существует?
alert( "test" in obj ); // true, свойство существует!
```
*Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).
```js
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```
*Упорядоченность свойств. Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.
```js
// Math.trunc - встроенная функция, которая удаляет десятичную часть
alert( String(Math.trunc(Number("49"))) ); // "49", то же самое ⇒ свойство целочисленное
alert( String(Math.trunc(Number("+49"))) ); // "49", не то же самое, что "+49" ⇒ свойство не целочисленное
alert( String(Math.trunc(Number("1.2"))) ); // "1", не то же самое, что "1.2" ⇒ свойство не целочисленное
```
Объекты – это ассоциативные массивы с рядом дополнительных возможностей.\
Они хранят свойства (пары ключ-значение), где:
- Ключи свойств должны быть строками или символами (обычно строками).
- Значения могут быть любого типа.
  
Чтобы получить доступ к свойству, мы можем использовать:
- Запись через точку: obj.property.
- Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].

Дополнительные операторы:
- Удаление свойства: delete obj.prop.
- Проверка существования свойства: "key" in obj.
- Перебор свойств объекта: цикл for for (let key in obj).

То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.

В JavaScript есть много других типов объектов:
- Array для хранения упорядоченных коллекций данных,
- Date для хранения информации о дате и времени,
- Error для хранения информации об ошибке.
  
# Копирование объектов

Одно из фундаментальных отличий объектов от примитивов заключается в том, что объекты хранятся и копируются «по ссылке», тогда как примитивные значения: строки, числа, логические значения и т.д. – всегда копируются «как целое значение».
```js
// В результате мы имеем две независимые переменные,
let message = "Привет!";
let phrase = message;
```
Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.
При копировании переменной объекта копируется ссылка, но сам объект не дублируется.
```js
let user = { name: 'John' };
let admin = user;
admin.name = 'Pete'; // изменено по ссылке из переменной "admin"
alert(user.name); // 'Pete'

let a = {};
let b = a; // копирование по ссылке
alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
alert( a === b ); // true
```
Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы.\
Синтаксис для копирования объекта: Object.assign(dest, [src1, src2, src3...]).\ - Где dest целевой объект
- Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
- Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. 
- Также существуют и другие методы клонирования объекта. Например, с использованием оператора расширения clone = {...user}
```js
let user = { name: "John" };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };
// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);
// теперь user = { name: "John", canView: true, canEdit: true }

let user = {
  name: "John",
  age: 30
};
let clone = {}; // новый пустой объект
// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}
```
# Вложенное клонирование
До сих пор мы предполагали, что все свойства user примитивныe. Но свойства могут быть и ссылками на другие объекты. Что с ними делать? Теперь недостаточно просто скопировать clone.sizes = user.sizes, потому что user.sizes – это объект, он будет скопирован по ссылке.
```js
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};
alert( user.sizes.height ); // 182

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, тот же объект

// user и clone обладают общим свойством sizes
user.sizes.width++;       // изменяем свойства в первом объекте
alert(clone.sizes.width); // 51, видим результат в другом

// глубокое клонирование
let user5 = structuredClone(user1);
```
Чтобы исправить это, мы должны использовать цикл клонирования, который проверяет каждое значение user[key] и, если это объект, тогда также копирует его структуру. Это называется «глубоким клонированием». \
Мы можем реализовать глубокое клонирование, используя рекурсию.Или, чтобы не изобретать велосипед заново, возьмите готовую реализацию, например _.cloneDeep(obj) из библиотеки JavaScript lodash.\
Также мы можем использовать глобальный метод structuredClone(), который позволяет сделать полную копию объекта. К сожалению он поддерживается только современными браузерами.\
Объекты, объявленные как константа, могут быть изменены \

# Сборка мусора

Основной концепцией управления памятью в JavaScript является принцип достижимости.\
Если упростить, то «достижимые» значения – это те, которые доступны или используются. \
Вдвижке JavaScript есть фоновый процесс, который называется сборщиком мусора. Он отслеживает все объекты и удаляет те, которые стали недоступными.
```js
// в user находится ссылка на объект
let user = {
  name: "John"
};
user = null; // удаляется объект
```
(*)Недостижимый "остров". Вполне возможна ситуация, при которой целый «остров» взаимосвязанных объектов может стать недостижимым и удалиться из памяти.
Бывший объект family был отсоединён от корня, на него больше нет ссылки, поэтому весь «остров» становится недостижимым и будет удалён.\
*Основной алгоритм сборки мусора называется «алгоритм пометок» (от англ. «mark-and-sweep») со следующими шагами:
- Сборщик мусора «помечает» (запоминает) все корневые объекты.
- Затем он идёт по ним и «помечает» все ссылки из них.
- Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
- …И так далее, пока не будут посещены все достижимые (из корней) ссылки.
- Все непомеченные объекты удаляются.

# Методы объекта, this

Объекты обычно создаются, чтобы представлять сущности реального мира.\
Функцию, которая является свойством объекта, называют "методом" этого объекта.
```js
let user = {
  name: "John",
  age: 30
};
user.sayHi = function() {
  alert("Привет!");
};
user.sayHi(); // Привет!
// сокращённая запись выглядит лучше, не так ли?
user = {
  sayHi() { // то же самое, что и "sayHi: function(){...}"
    alert("Привет");
    // "this" - это "текущий объект".
    alert(this.name);
  }
};
```
Нужно отметить, что эти две записи не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов.

# Ключевое слово «this» в методах

Как правило, методу объекта обычно требуется доступ к информации, хранящейся в объекте, для выполнения своей работы.\
*Для доступа к информации внутри объекта метод может использовать ключевое слово this*\
Значение this – это объект «перед точкой», который используется для вызова метода.\
Технически также возможно получить доступ к объекту без ключевого слова this, обратившись к нему через внешнюю переменную (в которой хранится ссылка на этот объект):(…Но такой код ненадёжен).
```js
let user = {
  name: "John",
  age: 30,
  sayHi() {
    alert(user.name); // "user" вместо "this"
  }
};
let admin = user;
user = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.
admin.sayHi(); // TypeError: Cannot read property 'name' of null
```
(*)«this» не является фиксированным!\
Значение this вычисляется во время выполнения кода, в зависимости от контекста.\
Правило простое: если вызывается obj.f(), то во время вызова f, this – это obj.\
Вызов без объекта: this == undefined \
В нестрогом режиме значением this в таком случае будет глобальный объект(window).\
В строгом режиме ("use strict") в таком коде значением this будет являться undefined. Если мы попытаемся получить доступ к this.name – это вызовет ошибку.
```js
function sayHi() {
  alert( this.name );
}

let user = { name: "John" };
let admin = { name: "Admin" };
// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;
// эти вызовы имеют  разное значение this
// "this" внутри функции - это объект "перед точкой"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin
```
В JavaScript this является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен, а скорее от того, какой объект вызывает метод.\
(*) У стрелочных функций нет «this»!
 Если мы ссылаемся на this внутри такой функции, то оно берётся из внешней «нормальной» функции.\
 Это особенность стрелочных функций. Она полезна, когда мы на самом деле не хотим иметь отдельное this, а скорее хотим взять его из внешнего контекста.
```js
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
```
Итого:
- Функции, которые находятся в свойствах объекта, называются «методами».
- Методы позволяют объектам «действовать»: object.doSomething().
- Методы могут ссылаться на объект через this.

Значение this определяется во время исполнения кода.

- При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
- Функция может быть скопирована между объектами (из одного объекта в другой).
Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object.

# Конструктор, оператор "new"

Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов, таких как пользователи, элементы меню.\
Это можно сделать при помощи функции-конструктора и оператора "new".
Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
- Имя функции-конструктора должно начинаться с большой буквы.
- Функция-конструктор должна выполняться только с помощью оператора "new".
  
Когда функция вызывается как new User(...), происходит следующее:
- Создаётся новый пустой объект, и он присваивается this.
- Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
- Возвращается значение this.

```js
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false

function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}
```
Таким образом, let user = new User("Jack") возвращает тот же результат, что и:
```js
let user = {
  name: "Jack",
  isAdmin: false
};
```
Теперь, если нам будет необходимо создать других пользователей, мы можем просто вызвать new User("Ann"), new User("Alice") и так далее. Данная конструкция гораздо удобнее и читабельнее, чем многократное создание литерала объекта.\
Это и является основной целью конструкторов – реализовать код для многократного создания однотипных объектов!\
[Давайте ещё раз отметим – технически любая функция (кроме стрелочных функций, поскольку у них нет this) может использоваться в качестве конструктора. Его можно запустить с помощью new, и он выполнит выше указанный алгоритм.
Такой конструктор не может быть вызван снова, так как он нигде не сохраняется, просто создаётся и тут же вызывается. Таким образом, этот трюк направлен на инкапсуляцию кода, который создаёт отдельный объект, без возможности повторного использования в будущем]
```js
// создаём функцию и сразу же вызываем её с помощью new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...другой код для создания пользователя
  // возможна любая сложная логика и инструкции
  // локальные переменные и так далее
};
```
(*) Проверка на вызов в режиме конструктора: new.target.\
Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new "в режиме конструктора" или без него "в обычном режиме".
```js
function User(name) {
  if (!new.target) { // в случае, если вы вызвали меня без оператора new
    return new User(name); // ...я добавлю new за вас
  }
  this.name = name;
}
// без "new":
User(); // undefined
// с "new":
new User('Dasha'); // function User { ... }
```
(*) Возврат значения из конструктора, return.\
Обычно конструкторы не имеют оператора return. Их задача – записать все необходимое в this, и это автоматически становится результатом.
Но если return всё же есть, то применяется простое правило:
- При вызове return с объектом, вместо this вернётся объект.
- При вызове return с примитивным значением, оно проигнорируется.
Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.
```js
function BigUser() {
  this.name = "John";
  return { name: "Godzilla" };  // <-- возвращает этот объект
}

alert( new BigUser().name );  // Godzilla, получили этот объект

function SmallUser() {
  this.name = "John";
  return; // <-- возвращает this
}
alert( new SmallUser().name );  // John
```
!Кстати, мы можем не ставить круглые скобки после new:\
[Пропуск скобок считается плохой практикой, но просто чтобы вы знали, такой синтаксис разрешён спецификацией]
```js
let user = new User; // <-- без скобок
```
(*) Создание методов в конструкторе.\
```js
function User(name) {
  this.name = name;
  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}
/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
```
# Опциональная цепочка '?.'
Опциональная цепочка ?. — это безопасный способ доступа к свойствам вложенных объектов, даже если какое-либо из промежуточных свойств не существует.\
Проблема «несуществующего свойства»!\
Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null.\
Далее в этой статье, для краткости, мы будем говорить, что что-то «существует», если оно не является null и не undefined.\
Обратите внимание: синтаксис ?. делает необязательным значение перед ним, но не какое-либо последующее.
```js
let user = {}; // пользователь без свойства "address"
alert(user.address.street); // Ошибка!
// неэлегантно
alert(user.address ? user.address.street : undefined);
alert(user.address ? user.address.street ? user.address.street.name : null : null);
// лучше
alert( user.address && user.address.street && user.address.street.name ); // undefined (без ошибки)
alert( user?.address?.street ); // undefined (без ошибки)
```
[Не злоупотребляйте опциональной цепочкой.\
К примеру, если, в соответствии с логикой нашего кода, объект user должен существовать, но address является необязательным, то нам следует писать user.address?.street, но не user?.address?.street.]
Переменная перед ?. должна быть объявлена!\
Если переменной user вообще нет, то user?.anything приведёт к ошибке:

(*) Другие варианты применения: ?.(), ?.[]\
Опциональная цепочка ?. — это не оператор, а специальная синтаксическая конструкция, которая также работает с функциями и квадратными скобками.\
Например, ?.() используется для вызова функции, которая может не существовать.\
Также мы можем использовать ?. с delete:\
Мы можем использовать ?. для безопасного чтения и удаления, но не для записи!
```js
let user = {
  firstName: "John",
  admin() {
    alert("Я админ");
  }
};
let userGuest = {};

user.admin?.(); // Я админ
userGuest.admin?.(); // ничего не произойдет (такого метода нет)

let key = "firstName";
alert( user?.[key] ); // John
alert( userGuest?.[key] ); // undefined

delete user?.name; // удаляет user.name если пользователь существует

user?.name = "John"; // Ошибка, не работает
```
Синтаксис опциональной цепочки ?. имеет три формы:
- obj?.prop – возвращает obj.prop если obj существует, в противном случае undefined.
- obj?.[prop] – возвращает obj[prop] если obj существует, в противном случае undefined.
- obj.method?.() – вызывает obj.method(), если obj.method существует, в противном случае возвращает undefined.

# Тип данных Symbol

*Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.*

По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.\
«Символ» представляет собой уникальный идентификатор!\
При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:
```js
// Создаём новый символ - id
let id = Symbol();
// Создаём символ id с описанием (именем) "id"
let id2 = Symbol("id");
```
Символы гарантированно уникальны! Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.
```js
let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
```
!Символы не преобразуются автоматически в строки\
[Например, функция alert принимает практически любое значение, автоматически преобразовывает его в строку]\
Это – языковая «защита» от путаницы, ведь строки и символы – принципиально разные типы данных и не должны неконтролируемо преобразовываться друг в друга.\
Если же мы действительно хотим вывести символ с помощью alert, то необходимо явно преобразовать его с помощью метода .toString(), вот так\
```js
let id = Symbol("id");

alert(id); // TypeError: Cannot convert a Symbol value to a string
alert(id.toString()); // Symbol(id), теперь работает
alert(id.description); // id Вывести описание.
```
## «Скрытые» свойства

Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.
```js
let user = {
  name: "Вася"
};
let id = Symbol("id");
user[id] = 1;

alert( user[id] ); // мы можем получить доступ к данным по ключу-символу
```
Почему же лучше использовать Symbol("id"), а не строку "id"?
Сторонний код может создать для этого свой символ Symbol("id"). Конфликта между их и нашим идентификатором не будет, так как символы всегда уникальны, даже если их имена совпадают. А вот если бы мы использовали строку "id" вместо символа, то тогда был бы конфликт.

## Символы в литеральном объекте

Используем квадратные скобки.\
Это вызвано тем, что нам нужно использовать значение переменной id в качестве ключа, а не строку «id».
```js
let id = Symbol("id");

let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};
```
(*) Символы игнорируются циклом for…in\
Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство. \
Object.keys(user) также игнорирует символы.
А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:
```js
let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
```

## Глобальные символы

!ногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью\
Например, разные части нашего приложения хотят получить доступ к символу "id", подразумевая именно одно и то же свойство.\
*Для этого существует глобальный реестр символов.*\
Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.\
Для чтения (или, при отсутствии, создания) символа из реестра используется вызов Symbol.for(key).
Он проверяет глобальный реестр и, при наличии в нём символа с именем key, возвращает его, иначе же создаётся новый символ Symbol(key) и записывается в реестр под ключом key.
```js
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true
```
Символы, содержащиеся в реестре, называются *глобальными символами*. Если вам нужен символ, доступный везде в коде – используйте глобальные символы.

(*) Symbol.keyFor

Symbol.keyFor(sym), наоборот, принимает глобальный символ и возвращает его имя.
```js
// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
```

## Системные символы

Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.\
Эти символы перечислены в спецификации в таблице Well-known symbols:
- Symbol.hasInstance
- Symbol.isConcatSpreadable
- Symbol.iterator
- Symbol.toPrimitive

Доступных как Symbol.*\
В частности, Symbol.toPrimitive позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву.

Технически символы скрыты не на 100%. Существует встроенный метод `Object.getOwnPropertySymbols(obj)` – с его помощью можно получить все свойства объекта с ключами-символами. Также существует метод `Reflect.ownKeys(obj)`, который возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны. Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.

# Преобразование объектов в примитивы

Что произойдёт, если сложить два объекта obj1 + obj2, вычесть один из другого obj1 - obj2 или вывести их на экран, воспользовавшись alert(obj)?\
В случае таких операций, объекты автоматически преобразуются в примитивы, затем выполняется сама операция над этими примитивами, и на выходе мы получим примитивное значение.

(*) Правила преобразования:
- Не существует преобразования к логическому значению. В логическом контексте все объекты являются true, всё просто. Существует лишь их числовое и строковое преобразование.
- Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции. Например, объекты Date (которые будут рассмотрены в главе Дата и время) могут быть вычтены, и результатом date1 - date2 будет разница во времени между двумя датами.
- Что касается преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.

(*) Хинты:\
Существует три варианта преобразования типов, которые происходят в различных ситуациях. Они называются «хинтами», как описано в спецификации:
1) "string": Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку
```js
// вывод
alert(obj);
// используем объект в качестве ключа
anotherObj[obj] = 123;
```
2) "number"
Для преобразования объекта к числу, в случае математических операций:
```js
// явное преобразование
let num = Number(obj);

// математические (не считая бинарного плюса)
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;
```
3) "default" Происходит редко, когда оператор «не уверен», какой тип ожидать.\
Например, бинарный плюс + может работать как со строками (объединяя их в одну), так и с числами (складывая их). Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для его преобразования.\
Также, если объект сравнивается с помощью == со строкой, числом или символом, тоже неясно, какое преобразование следует выполнить, поэтому используется хинт "default".\
Операторы сравнения больше/меньше, такие как < >, также могут работать как со строками, так и с числами. Тем не менее, по историческим причинам, они используют хинт "number", а не "default".
```js
// бинарный плюс использует хинт "default"
let total = obj1 + obj2;

// obj == number использует хинт "default"
if (user == 1) { ... };
```
Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:
1) Вызвать `obj[Symbol.toPrimitive](hint)` – метод с символьным ключом `Symbol.toPrimitive` (системный символ), если такой метод существует,
2) Иначе, если хинт равен "string"
попробовать вызвать `obj.toString()` или `obj.valueOf()`, смотря какой из них существует.
3) Иначе, если хинт равен "number" или "default"
попробовать вызвать `obj.valueOf()` или `obj.toString()`, смотря какой из них существует.

## Symbol.toPrimitive

Есть встроенный символ с именем `Symbol.toPrimitive`, который следует использовать для обозначения метода преобразования, вот так:\
Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.
```js
obj[Symbol.toPrimitive] = function(hint) {
  // вот код для преобразования этого объекта в примитив
  // он должен вернуть примитивное значение
  // hint = чему-то из "string", "number", "default"
};

let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```
## toString/valueOf
Если нет `Symbol.toPrimitive`, тогда JavaScript пытается найти методы toString и valueOf:
- Для хинта "string": вызвать метод toString, а если он не существует или возвращает объект вместо примитивного значения, то `valueOf` (таким образом, `toString` имеет приоритет при строковом преобразовании).
- Для других хинтов: вызвать метод `valueOf`, а если он не существует или возвращает объект вместо примитивного значения, то `toString` (таким образом, `valueOf` имеет приоритет для математических операций).

Эти методы должны возвращать примитивное значение. Если toString или valueOf возвращает объект, то он игнорируется (так же, как если бы метода не было).\
По умолчанию обычный объект имеет следующие методы toString и valueOf:
- Метод `toString` возвращает строку "[object Object]".
- Метод `valueOf` возвращает сам объект.
```js
let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
```
[Таким образом, если мы попытаемся использовать объект в качестве строки, как например в alert или вроде того, то по умолчанию мы увидим [object Object].]
```js
let user = {
  name: "John",
  money: 1000,
  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },
  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```
## Преобразование может вернуть любой примитивный тип

Единственное обязательное условие: эти методы должны возвращать примитив, а не объект.\
Как мы уже знаем, многие операторы и функции выполняют преобразования типов, например, умножение * преобразует операнды в числа.\
Если мы передаём объект в качестве аргумента, то в вычислениях будут две стадии:
1) Объект преобразуется в примитив (с использованием правил, описанных выше).
2) Если необходимо для дальнейших вычислений, этот примитив преобразуется дальше.
```js
let obj = {
  // toString обрабатывает все преобразования в случае отсутствия других методов
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4, объект был преобразован к примитиву "2", затем умножение сделало его числом
```
1) Умножение obj * 2 сначала преобразует объект в примитив (это строка "2").
2) Затем "2" * 2 становится 2 * 2 (строка преобразуется в число).
```js
let obj = {
  toString() {
    return "2";
  }
};

alert(obj + 2); // "22" ("2" + 2), преобразование к примитиву вернуло строку => конкатенация
```
Существует всего 3 типа (хинта) для этого:
1) "string" (для alert и других операций, которым нужна строка)
2) "number" (для математических операций)
3) "default" (для некоторых других операторов, обычно объекты реализуют его как "number")
Спецификация явно описывает для каждого оператора, какой ему следует использовать хинт.

Алгоритм преобразования таков:
1) Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует,
2) В случае, если хинт равен "string"
происходит попытка вызвать obj.toString() и obj.valueOf(), смотря что есть.
3) В случае, если хинт равен "number" или "default"
происходит попытка вызвать obj.valueOf() и obj.toString(), смотря что есть.
Все эти методы должны возвращать примитив (если определены).