# Структура кода

Инструкции – это синтаксические конструкции и команды, которые выполняют действия. Мы уже видели инструкцию alert('Привет, мир!').
Инструкции могут отделяться точкой с запятой.
В большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку.
В этом случае JavaScript интерпретирует перенос строки как «неявную» точку с запятой. Это называется автоматическая вставка точки с запятой.
```javascript
alert('Привет')
alert('Мир')
```
Но «в большинстве случаев» не значит «всегда»!
Но есть ситуации, где JavaScript «забывает» вставить точку с запятой там, где она нужна.
Ошибки, которые при этом появляются, достаточно сложно обнаруживать и исправлять.
```js
alert('Hello')

[1, 2].forEach(alert);
```
Это потому что JavaScript не вставляет точку с запятой перед квадратными скобками [...]. Получим:
```js
alert('Hello')[1, 2].forEach(alert);
// видимо ожидаем здесь возврат чего-то после выполнение функции и обращаемся к элементу массива, поэтому видим 'Hello' и error: TypeError: Cannot read properties of undefined (reading '2')
```
# Строгий режим 'use strict'

Новые функции добавлялись в язык, в то время как старая функциональность не менялась. Так было до 2009 года, когда появился ECMAScript 5 (ES5). Он добавил новые возможности в язык и изменил некоторые из существующих. Чтобы устаревший код работал, как и раньше, по умолчанию подобные изменения не применяются. Поэтому нам нужно явно их активировать с помощью специальной директивы: "use strict".
Когда она находится в начале скрипта, весь сценарий работает в «современном» режиме.
```js
"use strict";
// этот код работает в современном режиме
...
```
В начале большинства видов функций можно поставить "use strict". Это позволяет включить строгий режим только в конкретной функции. Но обычно люди используют его для всего файла.
Как только мы входим в строгий режим, отменить это невозможно.
```js
alert("some code");
// "use strict" ниже игнорируется - он должен быть в первой строке
"use strict";
// строгий режим не активирован
```
Над "use strict" могут быть записаны только комментарии.
Включаем его в консоли браузера:
```js
(function() {
  'use strict';
  // ...ваш код...
})()
```
Современный JavaScript поддерживает «классы» и «модули» — продвинутые структуры языка, которые автоматически включают строгий режим. Поэтому в них нет нужды добавлять директиву "use strict".
Подытожим: пока очень желательно добавлять "use strict"; в начале ваших скриптов. Позже, когда весь ваш код будет состоять из классов и модулей, директиву можно будет опускать.

# Переменные

Переменные используются для хранения информации.
Переменная – это «именованное хранилище» для данных. 
Для создания переменной в JavaScript используйте ключевое слово let.
Приведённая ниже инструкция создаёт (другими словами, объявляет) переменную с именем «message»:
```js
let message;
```
Теперь можно поместить в неё данные (другими словами, определить переменную), используя оператор присваивания =:
```js
let message;
message = 'Hello';
```
Строка сохраняется в области памяти, связанной с переменной. Мы можем получить к ней доступ, используя имя переменной:

```js
let user = 'John', age = 25, message = 'Hello';
```
Повторное объявление той же переменной является ошибкой.
В JavaScript есть два ограничения, касающиеся имён переменных:
- Имя переменной должно содержать только буквы, цифры или символы $ и _.
- Первый символ не должен быть цифрой.
Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое следующее слово начинается с заглавной буквы: myVeryLongName.
```js
let $ = 1; // объявили переменную с именем "$"
let _ = 2; // а теперь переменную с именем "_"

alert($ + _); // 3
```
!Регистр имеет значение
Переменные с именами apple и APPLE – это две разные переменные.

Нелатинские буквы разрешены, но не рекомендуются
```js
let имя = '...';
let 我 = '...';
```
Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.
Например: let, class, return и function зарезервированы.
```js
let let = 5; // нельзя назвать переменную "let", ошибка!
let return = 5; // также нельзя назвать переменную "return", ошибка!
```

```js
"use strict";
num = 5; // ошибка: num is not defined
```
Чтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let.
Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.
Названия таких констант пишутся с использованием заглавных букв и подчёркивания.
Константы известные еще до выполнения.
```js
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

# Типы данных

Примитивные - так как содержать одно значение(строка число или другое)

В JavaScript есть 8 основных типов данных.
Семь из них называют «примитивными» типами данных:
1 number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(2^53-1).
2 bigint для целых чисел произвольной длины.
3 string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
4 boolean для true/false.
5 null для неизвестных значений – отдельный тип, имеющий одно значение null.
6 undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
7 symbol для уникальных идентификаторов.
И один не является «примитивным» и стоит особняком:
8 object для более сложных структур данных.

Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.
Имеет две формы: typeof x или typeof(x).
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных числовому: Infinity, -Infinity и NaN.
Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.

Мы можем получить его в результате деления на ноль:
```js
alert( 1 / 0 ); // Infinity
alert( Infinity ); // Infinity задаем явно
```
NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
```js
alert( "не число" / 2 ); // NaN, такое деление является ошибкой
```
Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN:
```js
alert( NaN + 1 ); // NaN
alert( 3 * NaN ); // NaN
alert( "не число" / 2 - 1 ); // NaN
```
Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат (есть только одно исключение: NaN ** 0 равно 1)
Математические операции – безопасны
Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN как результат выполнения.
Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:
```js
// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;
```
*В JavaScript существует три типа кавычек.
- Двойные кавычки: "Привет".
- Одинарные кавычки: 'Привет'.
- Обратные кавычки: `Привет`.
Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:
```js
let name = "Иван";
// Вставим переменную
alert( `Привет, ${name}!` ); // Привет, Иван!
```
!Нет отдельного типа данных для одного символа.

*В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.
Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно»:
```js
let age = null;
```
*Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null. Оно означает, что «значение не было присвоено»:
```js
let age;
alert(age); // выведет "undefined"
```
…Но так делать не рекомендуется. Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.

*Тип object (объект) – особенный.
В объектах же хранят коллекции данных или более сложные структуры.

*Тип symbol (символ) используется для создания уникальных идентификаторов в объектах.
```js
typeof undefined // "undefined"

typeof 0.23 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)

typeof Infinity // "number"
```

# alert, prompt, confirm

*Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».

*Модальное означает, что пользователь не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до тех пор, пока взаимодействует с окном. 
```js
let result = prompt(title, [default]);
```
Введённый текст будет присвоен переменной result
```js
result = confirm(question);
```
Возвращает true/false
```js
```
Все эти методы являются модальными.

# Преобразование типов

Чаще всего операторы и функции автоматически приводят переданные им примитивные значения к нужному типу(alert, +)
1 String: Преобразование происходит очевидным образом. false становится "false", null становится "null" и т.п.
2 Number:
- undefined ->	NaN
- null ->	0
- true / false -> 	1 / 0
- string: 	Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
Учтите, что null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN
3 Boolean:
- Значения, которые интуитивно «пустые», вроде 0, пустой строки "", null, undefined и NaN, становятся false.
- Все остальные значения становятся true.
- Эту запись можно укоротить при помощи совмещённых операторов += и *=. Подобные краткие формы записи существуют для всех арифметических и побитовых операторов: /=, -=, **= и так далее.
- Инкремент ++ увеличивает переменную на 1
- Декремент -- уменьшает переменную на 1
- Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке
- Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
- «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.


```js
let value = true;
alert(typeof value); // boolean

value = String(value); // теперь value это строка "true"
alert(typeof value); // string

alert( "6" / "2" ); // 3, строки преобразуются в числа

let age = Number("Любая строка вместо числа"); // Nan

alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("Привет!") ); // true
alert( Boolean("") ); // false

alert( Boolean("0") ); // true
alert( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)
```
# Базовые операторы

- Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».
- Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный:
- Бинарным называется оператор, который применяется к двум операндам. 
- или оператор отрицания (унарный оператор, который обращает знак) и оператор вычитания (бинарный оператор, который вычитает одно число из другого).
- Взятие остатка от деления %
- Возведение в степень **
- В том случае, если в выражении есть несколько операторов – порядок их выполнения определяется приоритетом, или, другими словами, существует определённый порядок выполнения операторов.
- В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо. Такое присваивание работает справа налево.
- присваивание по цепочке
*Сложение строк:
- Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.
- Сложение и преобразование строк — это особенность бинарного плюса +
- Если операнд не число, унарный плюс преобразует его в число.
- Оператор «запятая» (,) редко применяется и является одним из самых необычных.
Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего. Оператор имеет очень низкий приоритет, ниже =, поэтому скобки важны в приведённом примере. Иногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке.

Приоритеты:
15	унарный плюс	+
15	унарный минус	-
14	возведение в степень	**
13	умножение	*
13	деление	/
12	сложение	+
12	вычитание	-
2	присваивание	=

```js
let x = 1;

x = -x;  // -1, применили унарный минус

let x = 1, y = 3;
alert( y - x ); // 2, бинарный минус вычитает значения

alert( 5 % 2 ); // 1, остаток от деления 5 на 2
alert( 8 % 4 ); // 0, остаток от деления 8 на 4

alert( 2 ** 2 ); // 2² = 4

let s = "моя" + "строка"; // моястрока

alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"

alert(2 + 2 + '1' ); // будет "41", а не "221"

alert( 6 - '2' ); // 4, '2' приводится к числу
alert( '6' / '2' ); // 3, оба операнда приводятся к числам

// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0

let apples = "2";
let oranges = "3";
alert( apples + oranges ); // "23"
// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5

let a = 1;
let b = 2;
let c = 3 - (a = b + 1);
alert( a ); // 3
alert( c ); // 0

a = b = c = 2 + 2; // цепочка присваиваний

let counter = 1;
let a = ++counter; // 2
let a = counter++; // 1

let a = (1 + 2, 3 + 4); // 7
a = 1 + 2, 3 + 4; //3

// три операции в одной строке
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
```

# Операторы сравнения

- Операторы сравнения возвращают значения логического типа.
- Строки сравниваются посимвольно в лексикографическом(алфавитном) порядке. Большей считается более длинная строка. Используется кодировка Unicode, а не настоящий алфавит. Заглавная буква "A" не равна строчной "a". Строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode).
- Значения разных типов при сравнении приводятся к числу. Операнды разных типов преобразуются оператором == к числу.  В итоге, и пустая строка, и false становятся нулём. Исключением является сравнение с помощью операторов строгого равенства/неравенства. Оператор строгого равенства === проверяет равенство без приведения типов. Другими словами, если a и b имеют разные типы, то проверка a === b немедленно возвращает false без попытки их преобразования. Ещё есть оператор строгого неравенства !==, аналогичный !=.
- Значения null и undefined равны == друг другу и не равны любому другому значению. При строгом равенстве === эти значения различны, так как различны их типы. !При нестрогом равенстве == эти значения равны друг другу и не равны никаким другим значениям.
- При использовании математических операторов и других операторов сравнения < > <= >= значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.
- undefined при сравнении преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях
- Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined.
```js
alert( 'Я' > 'А' ); // true
alert( 'Коты' > 'Кода' ); // true
alert( 'Сонный' > 'Сон' ); // true
console.log('коты' > 'Коты') // true

alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1

alert( true == 1 ); // true
alert( false == 0 ); // true

let a = 0;
alert( Boolean(a) ); // false
let b = "0";
alert( Boolean(b) ); // true
alert(a == b); // true!

alert( 0 == false ); // true
alert( '' == false ); // true
alert( 0 === false ); // false, так как сравниваются разные типы

alert( null == undefined ); // true
alert( null === undefined ); // false

alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true

alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

# Условное ветвление

Инструкция if (…) вычисляет выражение в скобках и преобразует результат к логическому типу:
- Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
- Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).
-Так называемый «условный» оператор «вопросительный знак» позволяет нам сделать это более коротким и простым способом. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента. Смысл оператора «вопросительный знак» ? – вернуть то или иное значение, в зависимости от условия. Пожалуйста, используйте его именно для этого

```js
if (condition) {} else if {}

let result = условие ? значение1 : значение2;
```
Иногда оператор «вопросительный знак» ? используется в качестве замены if:
Не рекомендуется использовать оператор вопросительного знака таким образом.
```js
(company == 'Netscape') ?
 alert('Верно!') : alert('Неправильно.');
```

# Логические операторы

Логическое значение — это примитивный тип данных, который хранит одно из двух значений: true или false.
Конвертирование - преобразование(либо обмен) чего-либо в иную форму или в другую координатную систему.

В JavaScript есть семь логических операторов:
1) || (ИЛИ)
2) ||= (Оператор логического присваивания ИЛИ)
3) && (И)
4) &&= (Оператор логического присваивания И)
5) ! (НЕ)
6) ?? (Оператор нулевого слияния)
7) ??= (Оператор нулевого присваивания)

Несмотря на своё название, данные операторы могут применяться к значениям любых типов. Полученные результаты также могут иметь различный тип.

*|| (ИЛИ)
Традиционно в программировании ИЛИ предназначено только для манипулирования булевыми значениями.
При выполнении ИЛИ || с несколькими значениями:
- Вычисляет операнды слева направо.
- Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
- Если все операнды являются ложными (false), возвращает последний из них.
- Значение возвращается в исходном виде, без преобразования.
Другими словами, цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.
```js
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false

alert( 1 || 0 ); // 1 (1 - истинное значение)
alert( true || 'какая-то строка' ); // true

alert( null || 1 ); // 1 (первое истинное значение)
alert( null || 0 || 1 ); // 1 (первое истинное значение)
alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)

let firstName = "";
let lastName = "";
let nickName = "Суперкодер";

alert( firstName || lastName || nickName || "Аноним"); // Суперкодер
```
!Обеспечивает так называемое "сокращенное вычисление"!.
Важность этой особенности становится очевидной, если операнд – это не просто значение, а выражение с сопутствующим эффектом, как, например, присваивание переменной или вызов функции.
```js
true || alert("никогда не сработает"); // нет сообщения
false || alert("сработает"); // "сработает"
```

*Оператор логического присваивания ИЛИ ||= принимает два операнда и выполняет следующие действия:
- Вычисляет операнды слева направо.
- Конвертирует a в логическое значение.
- Если a ложно, присваивает a значение b.
Концепция оператора ||= заключается в «сокращённом вычислении»!
Оператор логического присваивания ИЛИ ||= – это «синтаксический сахар», добавленный в язык в качестве более короткого варианта записи if-выражений с присваиванием.
```js
a ||= b; // a || (a = b);

let johnHasCar = false;

johnHasCar ||= "У Джона нет машины!"; // то же самое, что false || (johnHasCar = "...")
alert( johnHasCar ); // "У Джона нет машины!"
```
*И «&&» находит первое ложное значение.
Оператор && выполняет следующие действия:
- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.
Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.
Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.
```js
// Если первый операнд истинный,
// И возвращает второй:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert( null && 5 ); // null
alert( 0 && "какая-то строка" ); // 0
alert( 1 && 2 && null && 3 ); // null
alert( 1 && 2 && 3 ); // 3
```
!Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.
Таким образом, код a && b || c && d по существу такой же, как если бы выражения && были в круглых скобках: (a && b) || (c && d).

[Несмотря на то, что вариант с && кажется более коротким, if более нагляден и, как правило, более читабелен. Поэтому мы рекомендуем использовать каждую конструкцию по назначению: использовать if, если нам нужно if, и использовать &&, если нам нужно И.]

*Оператор логического присваивания И &&= записывается как два амперсанда && и символ присваивания =.
```js
// &&= присвоит a значение b только в том случае, если a истинно.
a &&= b; //a && (a = b);

let greeting = "Привет"; // строка непустая, поэтому будет преобразована к логическому значению true оператором &&=
greeting &&= greeting + ", пользователь!"; // то же самое, что true && (greeting = greeting + "...")
alert( greeting ) // "Привет, пользователь!"
```
*Оператор ! (НЕ) принимает один аргумент и выполняет следующие действия:
- Сначала приводит аргумент к логическому типу true/false.
- Затем возвращает противоположное значение.
Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.

# Оператор нулевого слиянтия

Оператор нулевого слияния представляет собой два вопросительных знака ??.\
Так как он обрабатывает null и undefined одинаковым образом, то для этой статьи мы введём специальный термин. Для краткости будем говорить, что значение «определено», если оно не равняется ни null, ни undefined.\
Результат выражения a ?? b будет следующим:
- если a определено, то a,
- если a не определено, то b.
Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.\
Как правило, оператор ?? нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой переменной.

С другой стороны, сравнительно недавно в язык был добавлен оператор нулевого слияния ?? – как раз потому, что многие были недовольны оператором ||.
!Важное различие между ними заключается в том, что:
- || возвращает первое истинное значение.
- ?? возвращает первое определённое значение.
Проще говоря, оператор || не различает false, 0, пустую строку "" и null/undefined. Для него они все одинаковы, т.е. являются ложными значениями. Если первым аргументом для оператора || будет любое из перечисленных значений, то в качестве результата мы получим второй аргумент.\
[На практике нулевая высота часто является вполне нормальным значением, которое не следует заменять значением по умолчанию. Таким образом, ?? здесь как раз работает так, как нужно.]

Приоритет оператора ?? такой же, как и у ||. Они оба равны 3.\
Это означает, что, как и ||, оператор нулевого слияния ?? вычисляется до = и ?, но после большинства других операций, таких как +, *.\
По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.
```js
result = a ?? b
result = (a !== null && a !== undefined) ? a : b;

let firstName = null;
let lastName = null;
let nickName = "Суперкодер";
// показывает первое значение, которое определено:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер

let firstName = null;
let lastName = null;
let nickName = "Суперкодер";
// показывает первое истинное значение:
alert(firstName || lastName || nickName || "Аноним"); // Суперкодер

let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0
```
*Оператор нулевого присваивания (??=).\
Предположим, нам необходимо проверить, равна ли переменная null или undefined, и если это так — присвоить этой переменной какое-либо другое значение.
```js
let userAge = null;
// 1
if (userAge === null || userAge === undefined) {
  userAge = 18;
}
// or 2
userAge ??= 18;

let userAge = 18;
userAge ??= alert("не сработает");
userAge ??= 21;
userAge ??= null;
alert(userAge) // по-прежнему 18
```

# Циклы
При написании скриптов зачастую встаёт задача сделать однотипное действие много раз.\
Для многократного повторения одного участка кода предусмотрены циклы.\
Одно выполнение тела цикла по-научному называется итерация.\
Это так называемое «встроенное» объявление переменной. Такие переменные существуют только внутри цикла.\
Вместо объявления новой переменной мы можем использовать уже существующую.
При этом он, как и любой другой цикл, может быть прерван директивой break.
Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву continue.
Обе этих директивы поддерживают метки, которые ставятся перед циклом. Метки – единственный способ для break/continue выйти за пределы текущего цикла, повлиять на выполнение внешнего.\
Заметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript нет такой возможности.\
Директива break должна находиться внутри блока кода. Технически, подойдет любой маркированный блок кода, например:
```js
while (condition) {
  // код
  // также называемый "телом цикла"
}

do {
  // тело цикла
} while (condition);

for (начало; условие; шаг) {
  // ... тело цикла ...
}
for (;;) {
  // будет выполняться вечно
}
```

```js
labelName: for (...) {
  ...
}

outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Значение на координатах (${i},${j})`, '');
    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)
    // сделать что-нибудь со значениями...
  }
}
alert('Готово!');
```

# Switch
Конструкция switch заменяет собой сразу несколько if.
Переменная x проверяется на строгое равенство первому значению value1.
Любое выражение может быть аргументом для switch/case.
```js
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]
  case 'value2':  // if (x === 'value2')
    ...
    [break]
  default:
    ...
    [break]
}
let a = "1";
let b = 0;

switch (+a) {
  case b + 1:
    alert("Выполнится, т.к. значением +a будет 1, что в точности равно b+1");
    break;

  default:
    alert("Это не выполнится");
}
```

# Функции

Зачастую нам надо повторять одно и то же действие во многих частях программы. Чтобы не повторять один и тот же код во многих местах, придуманы функции.
Для создания функций мы можем использовать объявление функции.
Этот пример явно демонстрирует одно из главных предназначений функций: избавление от дублирования кода.
Синтаксис называется Function Declaration (Объявление Функции):
```js
function имя(параметры) {
  ...тело...
}
```
Функция обладает полным доступом к внешним переменным и может изменять их значение.
У функции есть доступ к внешним переменным, например:
Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю. 
```js
let userName = 'Вася';
function showMessage() {
  let message = 'Привет, ' + userName;
  alert(message);
}
showMessage(); // Привет, Вася
```
*Глобальные переменные
Переменные, объявленные снаружи всех функций, такие как внешняя переменная userName в вышеприведённом коде – называются глобальными.
Глобальные переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).
Значение, передаваемое в качестве параметра функции, также называется аргументом.
Другими словами:
- Параметр – это переменная, указанная в круглых скобках в объявлении функции.
- Аргумент – это значение, которое передаётся функции при её вызове.
Если при вызове функции аргумент не был указан, то его значением становится undefined. Это не приведёт к ошибке.
В JavaScript параметры по умолчанию вычисляются каждый раз, когда функция вызывается без соответствующего аргумента.
В приведённом выше примере, функция anotherFunction() не будет вызвана вообще, если указан аргумент text.
Функция – это действие. Поэтому имя функции обычно является глаголом. 
Если функция не возвращает значения, это всё равно, как если бы она возвращала undefined.
!Одна функция – одно действие
```js
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() выполнится только если не передан text
  // результатом будет значение text
}
```
# Function expression

- Функции – это значения. Они могут быть присвоены, скопированы или объявлены в любом месте кода.
- Если функция объявлена как отдельная инструкция в основном потоке кода, то это “Function Declaration”.
- Если функция была создана как часть выражения, то это “Function Expression”.
- Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
- Функции, объявленные при помощи Function Expression, создаются только когда поток выполнения достигает их.

В большинстве случаев, когда нам нужно объявить функцию, Function Declaration предпочтительнее, т.к функция будет видна до своего объявления в коде. Это даёт нам больше гибкости в организации кода, и, как правило, делает его более читабельным.

Исходя из этого, мы должны использовать Function Expression только тогда, когда Function Declaration не подходит для нашей задачи. Мы рассмотрели несколько таких примеров в этой главе, и увидим ещё больше в будущем.

Существует ещё один синтаксис создания функций, который называется Function Expression (Функциональное Выражение).
Данный синтаксис позволяет нам создавать новую функцию в середине любого выражения.
Поскольку создание функции происходит в контексте выражения присваивания (с правой стороны от =), это Function Expression.
!Независимо от того, как создаётся функция – она является значением!
```js
let sayHi = function() { /* doing */};

alert( sayHi ); // выведет код функции
// browser: function() {}
// node: [Function: sayHi]
alert( sayHi.toString() ) // node: function() {}

let func = sayHi;    // (2) копируем
```
В JavaScript функция – это значение, поэтому мы можем обращаться с ней как со значением. риведённый выше код показывает её строковое представление, которое является её исходным кодом.
Ключевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно (от англ. «call back» – обратный вызов) когда-нибудь позже, если это будет необходимо.

!Функция – это значение, представляющее «действие»
Обычные значения, такие как строки или числа представляют собой данные.
Функции, с другой стороны, можно воспринимать как действия.
Мы можем передавать их из переменной в переменную и запускать, когда захотим.

Function Expression в сравнении с Function Declaration:
- Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.
- Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» =:
Более тонкое отличие состоит в том, когда! создаётся функция движком JavaScript.
!Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
После того, как поток выполнения достигнет правой части выражения присваивания let sum = function… – с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).
С Function Declaration всё иначе.
Function Declaration может быть вызвана раньше, чем она объявлена.

Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции. Можно считать этот процесс «стадией инициализации».
И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение.
В результате функции, созданные как Function Declaration, могут быть вызваны раньше своих определений.
Ещё одна важная особенность Function Declaration заключается в их блочной области видимости.
В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.
```js
'use strict'
let welcome;
{
  function welcome1() {
    console.log("Привет!");
  }
}
{
  welcome = function () {
    console.log("hi")
  }
}
welcome();
welcome1(); // Error: welcome is not defined
```

# Стрелочные функции

«функции-стрелки» или «стрелочные функции» (arrow functions), т.к. выглядит следующим образом:
```js
let func = (arg1, arg2, ...argN) => expression;
```
Стрелочные функции можно использовать так же, как и Function Expression.
Здесь мы представили главной целью стрелочных функций краткость. 


```js
```

```js
```


```js
```

```js
```
