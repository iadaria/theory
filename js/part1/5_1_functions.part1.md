# Рекурсия и стек

Рекурсия в JavaScript — это процесс вызова функцией самой себя. Функция, которая в своём теле вызывает сама себя, называется рекурсивной функцией.\
Внутри рекурсивной функции обязательно должно находиться условие выхода из рекурсии. Иначе функция будет вызывать саму себя бесконечно. Как только условие выхода выполняется, функция перестаёт вызывать себя.\
Чтобы предотвратить бесконечную рекурсию, можно использовать оператор if...else, в котором одна ветвь выполняет рекурсивный вызов, а другая — нет.\
Итеративный способ
```js
function pow(x, n) {
  let result = 1;

  // умножаем result на x n раз в цикле
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8
```
Рекурсивный способ: упрощение задачи и вызов функцией самой себя:
```js
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
```
Когда функция pow(x, n) вызывается, исполнение делится на две ветви:
Рекурсивное решение задачи обычно короче, чем итеративное.
```js
function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}
```
Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. В нашем случае она будет равна n.\
Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей.\
Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (execution context).

Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this и прочую служебную информацию.ё
Один вызов функции имеет ровно один контекст выполнения, связанный с ним.

Когда функция производит вложенный вызов, происходит следующее:
1) Выполнение текущей функции приостанавливается.
2) Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – *стеке контекстов выполнения*.
3) Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
4) После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлен.
5) Когда функция заканчивается(может возвращать результ), контекст её выполнения больше не нужен, поэтому он удаляется из памяти, а из стека восстанавливается предыдущий\
Как видно из иллюстраций выше, глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.\
Обратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, и в данном случае это приводит к тому, что возведение в степень n хранит в памяти n различных контекстов.\
Реализация возведения в степень через цикл гораздо более экономна.\
Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.\
Часто код с использованием рекурсии более короткий, лёгкий для понимания и поддержки. 

(*) Списки ... Реши хотя бы задачу

# Область видимости переменных, замыкание

JavaScript – язык с сильным функционально-ориентированным уклоном.\
Функция может быть динамически создана, скопирована в другую переменную или передана как аргумент другой функции и позже вызвана из совершенно другого места.\
Мы знаем, что функция может получить доступ к переменным из внешнего окружения

## Блоки кода
Если переменная объявлена внутри блока кода {...}, то она видна только внутри этого блока.\
Для if, for, while и т.д. переменные, объявленные в блоке кода {...}, также видны только внутри.\
Визуально let i = 0; находится вне блока кода {...}, однако здесь в случае с for есть особенность: переменная, объявленная внутри (...), считается частью блока.
```js
{
  let message = "Hello"; // переменная видна только в этом блоке
  alert(message); // Hello
}
{
  // показать другое сообщение
  let message = "Goodbye";
  alert(message);
}
alert(message); // ReferenceError: message is not defined

for (let i = 0; i < 3; i++) {
  // переменная i видна только внутри for
  alert(i); // 0, потом 1, потом 2
}
```
## Вложенные функции
Функция называется «вложенной», когда она создаётся внутри другой функции.
```js
function sayHiBye(firstName, lastName) {
  // функция-помощник, которую мы используем ниже
  function getFullName() {
    return firstName + " " + lastName;
  }
  alert( "Hello, " + getFullName() );
  alert( "Bye, " + getFullName() );
}
```
Что ещё интереснее, вложенная функция может быть возвращена: либо в качестве свойства нового объекта (если внешняя функция создаёт объект с методами), либо сама по себе. И затем может быть использована в любом месте. Не важно где, она всё так же будет иметь доступ к тем же внешним переменным.
```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++; // есть доступ к внешней переменной "count"
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```

# Лексическое окружение

В JavaScript у каждой выполняемой функции, блока кода {...} и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.\
Объект лексического окружения состоит из двух частей:
1) Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).
2) Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».\
Глобальное лексическое окружение, связанное со всем скриптом. У глобального лексического окружения нет внешнего окружения, так что она указывает на null.\
«Лексическое окружение» – это объект спецификации: он существует только «теоретически» в спецификации языка для описания того, как все работает. Мы не можем получить этот объект в нашем коде и манипулировать им напрямую.

Функция – это тоже значение, как и переменная.\
Разница заключается в том, что Function Declaration мгновенно инициализируется полностью.\
Когда создается лексическое окружение, Function Declaration сразу же становится функцией, готовой к использованию (в отличие от let, который до момента объявления не может быть использован).\
Именно поэтому мы можем вызвать функцию, объявленную как Function Declaration, до самого её объявления.

## 3.Внутреннее и внешнее лексическое окружение

Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.

Если переменная не была найдена, это будет ошибкой в строгом режиме (use strict). Без строгого режима, для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким же именем.

## 4.Возврат функции

Все функции помнят лексическое окружение, в котором они были созданы. Технически здесь нет никакой магии: все функции имеют скрытое свойство [[Environment]], которое хранит ссылку на лексическое окружение, в котором была создана функция.
Ссылка на [[Environment]] устанавливается один раз и навсегда при создании функции.\
! Переменная обновляется в том лексическом окружении, в котором она существует.

! Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").

То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], и все они могут получить доступ к внешним переменным.

Все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, как работает лексическое окружение.

## Сборка мусора

Обычно лексическое окружение удаляется из памяти вместе со всеми переменными после завершения вызова функции.  Это связано с тем, что на него нет ссылок. Как и любой объект JavaScript, оно хранится в памяти только до тех пор, пока к нему можно обратиться.\
Однако если существует вложенная функция, которая все еще доступна после завершения функции, то она имеет свойство [[Environment]], ссылающееся на лексическое окружение.\
В этом случае лексическое окружение остается доступным даже после завершения работы функции.
```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}
let g = f(); // g.[[Environment]] хранит ссылку на лексическое окружение
// из соответствующего вызова f()
```
Обратите внимание, что если f() вызывается много раз и результирующие функции сохраняются, то все соответствующие объекты лексического окружения также будут сохранены в памяти.  В приведенном ниже коде – все три:
```js
function f() {
  let value = Math.random();

  return function() { alert(value); };
}

// 3 функции в массиве, каждая из которых ссылается на лексическое окружение
// из соответствующего вызова f()
let arr = [f(), f(), f()];
```
Объект лексического окружения исчезает, когда становится недоступным (как и любой другой объект). Другими словами, он существует только до тех пор, пока на него ссылается хотя бы одна вложенная функция.
```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // пока существует функция g, value остается в памяти

g = null; // ...и теперь память очищена.
```
В приведенном ниже коде после удаления вложенной функции ее окружающее лексическое окружение (а значит, и value) очищается из памяти.

## Оптимизация на практике

Как мы видели, в теории, пока функция жива, все внешние переменные тоже сохраняются.

Но на практике движки JavaScript пытаются это оптимизировать. Они анализируют использование переменных и, если легко по коду понять, что внешняя переменная не используется – она удаляется.

Одним из важных побочных эффектов в V8 (Chrome, Edge, Opera) является то, что такая переменная становится недоступной при отладке.
```js
function f() {
  let value = Math.random();

  function g() {
    debugger; // в консоли: напишите alert(value); Такой переменной нет!
  }

  return g;
}

let g = f();
g();
```
Как вы можете видеть – такой переменной не существует! В теории, она должна быть доступна, но попала под оптимизацию движка.

# Остаточные параметры и оператор расширения

Многие встроенные функции JavaScript поддерживают произвольное количество аргументов.
Например:
- Math.max(arg1, arg2, ..., argN) – вычисляет максимальное число из переданных.
- Object.assign(dest, src1, ..., srcN) – копирует свойства из исходных объектов src1..N в целевой объект dest.

Как сделать чтобы функция поддерживала неограниченное количество аргументов?

## Остаточные параметры (...)

Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена.
Лишние аргументы не вызовут ошибку. Но, конечно, посчитаются только первые два.\
*Остаточные параметры могут быть обозначены через три точки .... Буквально это значит: «собери оставшиеся параметры и положи их в массив».*\
Остаточные параметры должны располагаться в конце
```js
function sum(a, b) {
  return a + b;
}

alert( sum(1, 2, 3, 4, 5) );
```
### Переменная "arguments"

Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.\
Хотя arguments похож на массив, и его тоже можно перебирать, это всё же не массив. Он не поддерживает методы массивов, поэтому мы не можем, например, вызвать arguments.map(...).\
К тому же, arguments всегда содержит все аргументы функции — мы не можем получить их часть. А остаточные параметры позволяют это сделать.\
!Стрелочные функции не имеют "arguments"\
[Если мы обратимся к arguments из стрелочной функции, то получим аргументы внешней «нормальной» функции(см код)]\
Как мы помним, у стрелочных функций нет собственного this. Теперь мы знаем, что нет и своего объекта arguments.\
Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.
```js
function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );

  // Объект arguments можно перебирать
  // for (let arg of arguments) alert(arg);
}
// Вывод: 2, Юлий, Цезарь
showName("Юлий", "Цезарь");
function f() {
  let showArg = () => alert(arguments[0]);
  showArg(2);
}
f(1); // 1
```
## Оператора расширения

Например, функция принимаем параметры/аргументы, а у нас есть массив. И мы хотим его предеать как параметры.
Когда ...arr используется при вызове функции, *он «расширяет» перебираемый объект arr в список аргументов*.\
Мы даже можем комбинировать оператор расширения с обычными значениями.\
Оператор расширения можно использовать и для слияния массивов.\
он работает с любым перебираемым объектом.\
С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.
```js
let arr = [3, 5, 1];
alert( Math.max(arr) ); // NaN
Math.max(...arr); // 5 (оператор "раскрывает" массив в список аргументов)
Math.max(...arr, ...arr, 25); 
let merged = [0, ...arr, 2, ...arr];

let str = "Привет";
alert( [...str] ); // П,р,и,в,е,т

let str = "Привет";
// Array.from преобразует перебираемый объект в массив
alert( Array.from(str) ); // П,р,и,в,е,т
```
Но между Array.from(obj) и [...obj] есть разница:
- Array.from работает как с псевдомассивами, так и с итерируемыми объектами
- Оператор расширения работает только с итерируемыми объектами
[Выходит, что если нужно сделать из чего угодно массив, то Array.from — более универсальный метод.]
```js
```

```js
```

```js
```

