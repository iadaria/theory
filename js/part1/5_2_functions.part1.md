# Устаревшее var
- Для «var» не существует блочной области видимости.
- Аналогично с циклами.
- Есть видимость внутри функции, те снаружи будет ошибка если захочем получить доступ к переменной внутри функции.
- «var» допускает повторное объявление.
- «var» обрабатываются в начале запуска функции\
Это поведение называется «hoisting» (всплытие, поднятие), потому что все объявления переменных var «всплывают» в самый верх функции.
- Объявления переменных «всплывают», но присваивания значений – нет.
```js
if (true) {
  var test = true; // используем var вместо let
}
alert(test); // true, переменная существует вне блока if

var user = "Пётр";
var user; // ничего не делает, переменная объявлена раньше
// ...нет ошибки

alert(user); // Пётр

function sayHi() {
  phrase = "Привет";
  alert(phrase);
  var phrase;
}
sayHi();
function sayHi() {
  var phrase; // объявление переменной срабатывает вначале...
  alert(phrase); // undefined
  phrase = "Привет"; // ...присвоение - в момент, когда исполнится данная строка кода.
}
sayHi();
```
## IIFE
В прошлом, поскольку существовал только var, а он не имел блочной области видимости, программисты придумали способ её эмулировать.\
«Immediately-invoked function expressions» (сокращенно IIFE).\
Так что скобки вокруг функции – это трюк, который позволяет объяснить JavaScript, что функция была создана в контексте другого выражения, а значит, что это Function Expression: ей не нужно имя и её можно вызвать немедленно.
```js
(function() {
  var message = "Привет";
  alert(message); // Привет
})();

// ошибка синтаксиса из-за скобок ниже
function go() {

}(); // <-- нельзя вызывать Function Declaration немедленно
```
```js
// Способы создания IIFE
(function() {
  alert("Круглые скобки вокруг функции");
})();

(function() {
  alert("Круглые скобки вокруг всего выражения");
}());

!function() {
  alert("Выражение начинается с логического оператора НЕ");
}();

+function() {
  alert("Выражение начинается с унарного плюса");
}();
```
Во всех перечисленных случаях мы объявляем Function Expression и немедленно запускаем его.

# Глобальный объект
Глобальный объект предоставляет переменные и функции, доступные в любом месте программы. По умолчанию это те, что встроены в язык или среду исполнения.

В браузере он называется `window`, в Node.js — `global`, в другой среде исполнения может называться иначе.

Недавно `globalThis` был добавлен в язык как стандартизированное имя для глобального объекта, которое должно поддерживаться в любом окружении. Он поддерживается во всех основных браузерах.

- В браузере глобальные функции и переменные, объявленные с помощью var (не let/const!), 
- Если бы мы объявили переменную при помощи let, то такого бы не произошло.
- Если свойство настолько важное, что вы хотите сделать его доступным для всей программы, запишите его в глобальный объект напрямую.
```js
alert("Привет");
// это то же самое, что и
window.alert("Привет");

var gVar = 5;
alert(window.gVar); // 5 (становится свойством глобального объекта)

let gLet = 5;
alert(window.gLet); // undefined

// сделать информацию о текущем пользователе глобальной, для предоставления доступа всем скриптам
window.currentUser = {
  name: "John"
};
// где угодно в коде
alert(currentUser.name); // John

```
[При этом обычно не рекомендуется использовать глобальные переменные. Следует применять их как можно реже.]

## Использование полифилов
Глобальный объект можно использовать, чтобы проверить поддержку современных возможностей языка.ё
Например, проверить наличие встроенного объекта Promise (такая поддержка отсутствует в очень старых браузерах).
Если нет (скажем, используется старый браузер), мы можем создать *полифил: добавить функции, которые не поддерживаются окружением, но существуют в современном стандарте.*
```js
if (!window.Promise) {
  alert("Ваш браузер очень старый!");
  window.Promise = ... // собственная реализация современной возможности языка
}
```

# Объект функции, NFE

Как мы уже знаем, в JavaScript функция – это значение.\
Каждое значение в JavaScript имеет свой тип.\
В JavaScript функции – это объекты.\
Можно представить функцию как «объект, который может делать какое-то действие». Функции можно не только вызывать, но и использовать их как обычные объекты: добавлять/удалять свойства, передавать их по ссылке и т.д.

(*) 1.Свойство «name»\
Она присваивает корректное имя даже в случае, когда функция создаётся без имени и тут же присваивается, вот так.\
Даже в случае присваивания значения по умолчанию.\
*В спецификации это называется «контекстное имя»: если функция не имеет name, то JavaScript пытается определить его из контекста.*\
В этом нет никакой магии. Бывает, что корректное имя определить невозможно. В таких случаях свойство name имеет пустое значение
```js
function sayHi() {
  alert("Hi");
}
alert(sayHi.name); // sayHi

let sayHi2 = function() {
  alert("Hi");
};
alert(sayHi2.name); // sayHi2 (есть имя!)

function f(sayHi3 = function() {}) {
  alert(sayHi3.name); // sayHi3 (работает!)
}

let user = {
  sayHi() {
    // ...
  },
  sayBye: function() {
    // ...
  }
}
alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye

// функция объявлена внутри массива
let arr = [function() {}];
alert( arr[0].name ); // <пустая строка>
```

(*) 2. Свойство «length»\
«length» содержит количество параметров функции в её объявлении.
```js
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
```
(*) 3. Пользовательские свойства\
Мы также можем добавить свои собственные свойства.\
! Свойство не есть переменная!\
Другими словами, свойство counter и переменная let counter – это две независимые вещи.
[Мы можем использовать функцию как объект, хранить в ней свойства, но они никак не влияют на её выполнение. Переменные – это не свойства функции и наоборот. Это два параллельных мира.]
```js
function sayHi() {
  alert("Hi");
  // давайте посчитаем, сколько вызовов мы сделали
  sayHi.counter++;
}
sayHi.counter = 0; // начальное значение

sayHi(); // Hi
sayHi(); // Hi
alert( `Вызвана ${sayHi.counter} раза` ); // Вызвана 2 раза
```
Иногда свойства функции могут использоваться вместо замыканий.\
[Например, мы можем переписать функцию-счётчик, используя её свойство:]
```js
function makeCounter() {
  // вместо
  // let count = 0
  function counter() {
    return counter.count++;
  };
  counter.count = 0;
  return counter;
}

let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1
counter.count = 10;
counter(); // 10
```
Свойство count теперь хранится прямо в функции, а не в её внешнем лексическом окружении.\
Основное отличие в том, что если значение count живёт во внешней переменной, то оно не доступно для внешнего кода. Изменить его могут только вложенные функции. А если оно присвоено как свойство функции, то мы можем его получить.

# Named Function Expression

Named Function Expression или NFE – это термин для Function Expression, у которого есть имя.
```js
// Function Expression
let sayHi = function(who) {
  alert(`Hello, ${who}`);
};
// И присвоим ему имя
let sayHi = function func(who) {
  alert(`Hello, ${who}`);
};
```
Что это дает(name func)?
[Для начала заметим, что функция всё ещё задана как Function Expression. Добавление "func" после function не превращает объявление в Function Declaration, потому что оно все ещё является частью выражения присваивания.]
! Есть две важные особенности имени func, ради которого оно даётся:
- Оно позволяет функции ссылаться на себя же.
- Оно не доступно за пределами функции.
```js
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // использует func, чтобы снова вызвать себя же
  }
};
sayHi(); // Hello, Guest
// А вот так - не cработает:
func(); // Ошибка, func не определена (недоступна вне функции)
```
Почему мы используем func? Почему просто не использовать sayHi для вложенного вызова?
```js
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi("Guest");
  }
};
```
Однако, у этого кода есть проблема, которая заключается в том, что значение sayHi может быть изменено. Функция может быть присвоена другой переменной, и тогда код начнёт выдавать ошибки:
```js
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi("Guest"); // Ошибка: sayHi не является функцией
  }
};
let welcome = sayHi;
sayHi = null;
welcome(); // Ошибка, вложенный вызов sayHi больше не работает!
```
! Так происходит, потому что функция берёт sayHi из внешнего лексического окружения.\
Так как локальная переменная sayHi отсутствует, используется внешняя. И на момент вызова эта внешняя sayHi равна null.\
! Необязательное имя, которое можно вставить в Function Expression, как раз и призвано решать такого рода проблемы !
```js
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // Теперь всё в порядке
  }
};
let welcome = sayHi;
sayHi = null;
welcome(); // Hello, Guest (вложенный вызов работает)
```
Теперь всё работает, потому что имя "func" локальное и находится внутри функции. Теперь оно взято не снаружи (и недоступно оттуда). Спецификация гарантирует, что оно всегда будет ссылаться на текущую функцию.

Внешний код все ещё содержит переменные sayHi и welcome, но теперь func – это «внутреннее имя функции», таким образом она может вызвать себя изнутри.

# Стрелочные функции

Стрелочные функции – это не просто «сокращение», чтобы меньше писать. У них есть ряд других полезных особенностей.\
Если не хотим выходить из текущего контекста. Здесь как раз и полезны стрелочные функции.\
! У стрелочных функций нет «this» \
! Если происходит обращение к this, его значение берётся снаружи.\
! Стрелочные функции нельзя использовать с new. Они не могут использоваться как конструкторы.\
! Стрелочные функции не имеют «arguments».\
! У них также нет super
```js
let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
    this.students.forEach(function(student) {
      // Error: Cannot read property 'title' of undefined
      alert(this.title + ': ' + student)
    });
  }
};
group.showList();
```
Если бы мы использовали «обычную» функцию, была бы ошибка\
Ошибка возникает потому, что forEach по умолчанию выполняет функции с this, равным undefined, и в итоге мы пытаемся обратиться к undefined.title.
```js
function defer(f, ms) {
  return function() {
    setTimeout(() => f.apply(this, arguments), ms)
  };
}
function sayHi(who) {
  alert('Hello, ' + who);
}
let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred("John"); // выводит "Hello, John" через 2 секунды
// Или
function defer(f, ms) {
  return function(...args) {
    let ctx = this;
    setTimeout(function() {
      return f.apply(ctx, args);
    }, ms);
  };
}
```

# new Function

Существует ещё один вариант объявления функции. Он используется крайне редко, но иногда другого решения не найти.
```js
let func = new Function([arg1, arg2, ...argN], functionBody);
```
Функция создаётся с заданными аргументами `arg1...argN` и телом `functionBody`.\
Функция создаётся полностью «на лету» из строки, переданной во время выполнения.\
Но new Function позволяет превратить любую строку в функцию.
[Это используется в очень специфических случаях, например, когда мы получаем код с сервера для динамической компиляции функции из шаблона, в сложных веб-приложениях.]
```js
let sum = new Function('a', 'b', 'return a + b');

alert( sum(1, 2) ); // 3
```
(*) Замыкание\
Обычно функция запоминает, где родилась, в специальном свойстве [[Environment]]. Это ссылка на лексическое окружение (Lexical Environment), в котором она создана.\
Но когда функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное. Поэтому такая функция имеет доступ только к глобальным переменным.\
Если бы new Function имела доступ к внешним переменным, при этом были бы проблемы с минификаторами.\
[Например, если в функции объявляется переменная let userName, то минификатор изменяет её на let a]
```js
function getFunc() {
  let value = "test";

  let func = new Function('alert(value)');

  return func;
}
getFunc()(); // ошибка: value не определено
// было
function getFunc() {
  let value = "test";

  let func = function() { alert(value); };

  return func;
}
getFunc()(); // "test", из лексического окружения функции getFunc
```

```js
```

```js
```

```js
```

```js
```

```js
```

```js
```

```js
```

```js
```

```js
```

```js
```
