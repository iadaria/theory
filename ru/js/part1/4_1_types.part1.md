# Типы данных

## Методы примитивов

JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они являются объектами. У них есть и методы

Отличие от примитивов:
- Это – значение «примитивного» типа. Одно значение.
- Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint.

Объект
- Может хранить множество значений как свойства.
- Объявляется при помощи фигурных скобок {}, например: {name: "Рома", age: 30}. В JavaScript есть и другие виды объектов: например, функции тоже являются объектами.
- Одна из лучших особенностей объектов – это то, что мы можем хранить функцию как одно из свойств объекта.
  
Объекты «тяжелее» примитивов. Они нуждаются в дополнительных ресурсах для поддержания внутренней структуры.\
Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean, Symbol и BigInt.\
К примеру, существует метод `str.toUpperCase()`, который возвращает строку в верхнем регистре.\
1) В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы.
2) Этот метод запускается и возвращает новую строку
3) Специальный объект удаляется, оставляя только примитив str.\
Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».
```js
'Hello'.toUpperCase(); // HELLO
```
`new` в JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется.\
С другой стороны, использование функций String/Number/Boolean без оператора new – вполне разумно и полезно. Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевый тип.
```js
alert( typeof 0 ); // "число"
alert( typeof new Number(0) ); // "object"!

let num = Number("123"); // превращает строку в число
```
!null/undefined не имеют методов.\
У них нет соответствующих «объектов-обёрток», и они не имеют никаких методов. В некотором смысле, они «самые примитивные».

# Числа
В современном JavaScript существует два типа чисел:
- Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с плавающей точкой двойной точности» 
- BigInt числа дают возможность работать с целыми числами произвольной длины. Они нужны достаточно редко и используются в случаях, когда необходимо работать со значениями более чем (253-1) или менее чем -(253-1).
```js
// Один из способов записи
let billion = 1_000 // 1000
let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
let mcs = 0.000001;
let mcsE = 1e-6; // шесть нулей слева
alert( 0xff ); // 255

1e-3 === 1 / 1000; // (=0.001)
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255.
```
- Символ нижнего подчёркивания _ – это «синтаксический сахар»
- "e" умножает число на 1 с указанным количеством нулей.
- Естественно, есть короткий стиль записи: 0x, используется в представлении цветов.

Функции:
- `toString(base)` Метод `num.toString(base)` возвращает строковое представление числа num в системе счисления base.
- Если нам надо вызвать метод непосредственно на числе, то нам надо поставить две точки .. после числа(после первой точки начинается десятичная часть, а две точки значит что она отсутствует).
- Округление: `Math.floor`, `Math.ceil`, `Math.round`, `Math.trunc`.
- `num.toFixed(n)` оклугляет до `n` знаков после запятой и возвращает строковое значение.
- обходим проблему неточности в js с помощью округления `sum.toFixed(2)`
- Другим забавным следствием внутреннего представления чисел является наличие двух нулей: `0` и `-0`. Все потому, что знак представлен отдельным битом, так что, любое число может быть положительным и отрицательным, включая нуль.\
- ` isFinite и isNaN`
- `Infinity (и -Infinity)` — особенное численное значение, которое ведёт себя в точности как математическая бесконечность `∞`.
- `NaN `представляет ошибку.
- `isNaN(value)` преобразует значение в число и проверяет является ли оно NaN
[Нужна ли нам эта функция? Разве не можем ли мы просто сравнить === NaN? К сожалению, нет. Значение NaN уникально тем, что оно не является равным ничему другому, даже самому себе:]
- `isFinite(value)` преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:
- Методы `Number.isNaN и Number.isFinite` – это более «строгие» версии функций `isNaN и isFinite`. Они не преобразуют аргумент в число, а наоборот – первым делом проверяют, является ли аргумент числом (принадлежит ли он к типу number).
- Строки в JavaScript кодируются в UTF-16
- `str.trim()` — убирает пробелы в начале и конце строки
- `str.repeat(n)` — повторяет строку n раз.
- `str.replace(regexp|substr, newSubStr|function[, flags])`

```js
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111

12356..toString(36) // в 36-разр сис.сч.

let num = 12.34;
alert( num.toFixed(1) ); // "12.3"

5..toFixed(5); //"5.00000" 

// Переполнили 64-битное хранилище
alert( 1e500 ); // Infinity 

alert( 0.1 + 0.2 ); // 0.30000000000000004

alert( NaN === NaN ); // false

alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, потому что специальное значение: NaN
alert( isFinite(Infinity) ); // false, 
```
[Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.\
Другими словами, что такое 0.1? Это единица делённая на десять — 1/10, одна десятая. В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: 1/3, которая становится бесконечной дробью 0.33333(3).\
Деление на 10 гарантированно хорошо работает в десятичной системе, но деление на 3 – нет\
1/10 становится бесконечной дробью.ё
Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак. ]

```js
alert(0.1.toString(2)); // 0.0001100110011001100110011001100110011001100110011001101
alert(0.2.toString(2)); // 0.001100110011001100110011001100110011001100110011001101
alert((0.1 + 0.2).toString(2)); // 0.0100110011001100110011001100110011001100110011001101

alert( +0.1.toFixed(20) ); // 0.10000000000000000555

alert( 9999999999999999 ); // покажет 10000000000000000
```
Существует специальный метод `Object.is`, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:
- Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
- Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.

(*) `parseInt и parseFloat`

Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:
Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число.\
Второй аргумент `parseInt(str, radix)` система счисления: 16, 36.
```js
alert( +"100px" ); // NaN
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй 

parseInt('a123'); // NaNточке
parseInt('5', 8); // 5
11..toString(2); // 1011
```

# Строки

- Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}:
- Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:
- Многострочные строки также можно создавать с помощью одинарных и двойных кавычек, используя так называемый «символ перевода строки», который записывается как \n:
- Свойство length содержит длину строки:
- Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: `[pos]`. Также можно использовать метод `str.at(pos)` - допускает отрицательный индекс. Первый символ занимает нулевую позицию:
- `.at(-1)` означает последний символ
- Также можно перебрать строку посимвольно, используя `for..of`:
- Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его.
```js
function sum(a, b) {
  return a + b;
}
alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.

// перевод строки добавлен с помощью символа перевода строки
let str1 = "Hello\nWorld";

// многострочная строка, созданная с использованием обратных кавычек
let str2 = `Hello
World`;

`My\n`.length; // 3

let str = `Hello`;
// получаем первый символ
alert( str[0] ); // H
alert( str.at(0) ); // H

alert( str[-2] ); // undefined
alert( str.at(-2) ); // l

str[0] = 'h'; // ошибка

for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т.д.)
}
```
(*) Methods:
- Методы `toLowerCase()` и `toUpperCase()` меняют регистр символов:
- `str.indexOf(substr, pos)` - поиск подстроки `substr` в строке `str`, начиная с позиции `pos`, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений. Чтобы запустить все вхождения нужен цикл.
- `str.lastIndexOf(substr, position)` ищем с конца строки;
- `includes, startsWith, endsWith`
- `substring, substr и slice` Получение подстроки
- `str.substring(start [, end])`. Возвращает часть строки между start и end (не включая) end.
- `str.substr(start [, length])`. Возвращает часть строки от start длины length.
- `str.codePointAt(pos)` Строки кодируются в UTF-16. Таким образом, у любого символа есть соответствующий код. Есть специальные методы, позволяющие получить символ по его коду и наоборот.
- `String.fromCodePoint(code)`. Создаёт символ по его коду code.
- Правильное сравнивание. `str.localeCompare(str2)`. Поэтому браузеру нужно знать, какой язык использовать для сравнения. У этого метода есть два дополнительных аргумента, которые указаны в документации. Первый позволяет указать язык (по умолчанию берётся из окружения) — от него зависит порядок букв. Второй — определить дополнительные правила, такие как чувствительность к регистру, а также следует ли учитывать различия между "a" и "á".
```js
let word = "Dasha";
word.indexOf("ash"); //2

"Hello".includes("Bye"); // false
"Midget".includes("id"); // true
"Widget".startsWith("Wid"); // true
"Widget".endsWith("get"); // true

let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
str.slice(0, 5);
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
str.slice(0, 1);
str.slice(2); // до конца
// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
str.slice(-4, -1); // gif
str.substring(2, 6); // "ring"
str.substr(2, 4); // ring

String.fromCodePoint(90); // Z
// Теперь очевидно, почему a > Z.
// Код a (97) больше кода Z (90)
'Österreich'.localeCompare('Zealand'); // -1
// Отрицательное число, если str меньше str2

a.localeCompare(b, 'en', { sensitivity: 'base' });
"dasha".repeat(5);// "dashadashadashadashadasha"
"dasha".replaceAll("a", "b",); //"dbshb"
```

# Массивы

Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, Array.
- В массиве могут храниться элементы любого типа.
- «Висячая запятая» упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными.
- Получение последних элементов при помощи `«at»`. Новая возможностью
- `push` добавляет элемент в конец.
- `shift` удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.
- очередь - push and shift, первый зашел - первый вышел
- стек - первым вошел - первым вышел fifo - first-in first-out
- `push` добавляет элемент в конец.
- `pop` удаляет последний элемент.
- `unshift` добавляем элемент в начала массива
- Движок JavaScript старается хранить элементы массива в непрерывной области памяти;
- Методы push/pop выполняются быстро, а методы shift/unshift – медленно.
[Операция shift должна выполнить 3 действия:
1) Удалить элемент с индексом 0.
2) Сдвинуть все элементы влево, заново пронумеровать их, заменив 1 на 0, 2 на 1 и т.д.
3) Обновить свойство length .
]
- Свойство length автоматически обновляется при изменении массива. Если быть точными, это не количество элементов массива, а наибольший цифровой индекс плюс один.
- А что же с push/pop? Им не нужно ничего перемещать.
- Ещё один интересный факт о свойстве length – его можно перезаписать.
- самый простой способ очистить массив – это arr.length = 0;
- Если new Array вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов, но с заданной длиной.
- `toString()` список элементов разделенных запятыми
- Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString, таким образом
- Два объекта равны друг другу == только в том случае, если они ссылаются на один и тот же объект.
```js
let arr = new Array(); //
let arr = []; //
let arr = new Array("Яблоко", "Груша", "и тд"); //

let fruits = ["Apple", "Orange", "Plum"];
fruits[-1]; // undefined
fruits.at(-1); // Plum
fruits.pop(); // del Plum
furits.push("Plum"); // add Plum

let fruits = ["Яблоко"];
fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");
// ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
alert( fruits );

let fruits = []; // создаём массив
fruits[99999] = 5; // создаём свойство с индексом, намного превышающим длину массива
fruits.age = 25; // создаём свойство с произвольным именем

// проходит по значениям
for (let fruit of fruits) {
  alert( fruit );
}
for (let key in arr) {
  alert( arr[key] ); // Яблоко, Апельсин, Груша
}

let fruits = [];
fruits[123] = "Яблоко";
fruits.length; // 124

let arr = [1, 2, 3, 4, 5];
arr.length = 2; // укорачиваем до двух элементов
alert( arr ); // [1, 2]

let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
let arr = [1, 2, 3]; // String(arr) === '1,2,3'
alert( [] == [] ); // false
alert( [0] == [0] ); // false

alert( 0 == [] ); // true
alert('0' == [] ); // false
alert( 0 == '' ); // true, так как '' преобразуется в число 0
alert('0' == '' ); // false, нет преобразования типов, разные строки

[...Array(5).keys()]; // [0, 1, 2, 3, 4]
```
Таким образом, массив [] преобразуется в примитив с целью сравнения и становится пустой строкой ''\
 Вместо этого сравните их по элементам в цикле или используя методы итерации, описанные в следующей главе.
```js
```


```js
```

```js
```

```js
```


```js
```