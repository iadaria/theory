# Event Loop в деталях

JS был спроектирован как однопоточный язык программирования. Это значит, что он может выполнять только одну операцию одновременно.  Тем не менее у JavaScript есть такой механизм как Event Loop, который как раз и позволяет выполнять "асинхронные" операции.  Да просто потому что JavaScript тоже выполняет их синхронно, асинхронности в самом JavaScript как таковой нет.

Тут в силу и вступает Event Loop. Так как setTimeout это асинхронная операция (таймер высчитывается на стороне браузера, а не в JS).

Другое дело обстоит с таймером, время которое ожидает таймаут будет считаться на стороне браузера, поэтому операция как бы "пропадет" из очереди. Таймер попал в Event Loop, где будет ждать покуда браузер не пришлет сигнал, о том что время для таймаута вышло и коллбэк внутри таймера можно выполнять.

Теперь самое неочевидное: даже если таймаут выполнился, а функция в которой мы выполняем все синхронные операции еще не выполнилась, Event Loop будет держать все что в нем содержится, покуда у нас не очистится Call Stack. Только после того как все синхронные операции в функции выполнились Event Loop отдаст нам наш таймер, который мы сможем выполнить:

Однако у Event Loop'а тоже есть свои правила. Он делит все задачи на подтипы:
- Микрозадачи
- Макрозадачи
- Задачи отрисовки

Движок у нас отвечает:
- сборку мусора
- стек вызовов Call Stack и куча Cheap
- Компиляция JS в машинный код
- Отпимизация, скрытые классы

Event-loop:
- асинхронный-код

Event-loop не является частью движка, а предоставляется средой.
Браузер nodejs или другой. Устройство может быть разной.

В Chrome - v8 и в NodeJs- v8.

Взаимодействие между event-loop и движка через web-api.

Синхронные задачи выполняются в Call Stack.
Очередь микрозадач и очень макрозадач.

МИкратаски:
1 Промисы
2 queueMicrotask
3 mutationObserver

МАкротаски:
- Таймеры (setTimeout, setInterval)
- События (клик, загрузка изображений)
- Браузерные нюансы (рендер, I/O)

# await

`await` заставляет асинхронную функцию ждать выполнение промиса (его значения). Чтобы получить значение выполненного промиса, мы должны присвоить переменной ожидаемое (awaited) значение промиса.
```js
const one = () => Promise.resolve('One!');

async function myFunc() {
  console.log('In function!');
  const res = await one();
  console.log(res);
}

console.log('Before functions');
myFunc();
console.log('After function!')
```
Шаги:
1. Сначала движок видит `console.log`. Данный метод помещается в стек, в консоль выводится `Before function!`.
2. Затем вызывается асинхронная функция `myFunc()`, выполняется ее код. В первой строке этого кода мы вызываем второй `console.log` со строкой 'In function!'. Данный метод добавляется в стек, его значение выводится в консоль, и он удаляется из стека.
Call stack: [script, myFunc, one, Promise.resolve()]
```js
```

```js
```

```js
```

```js
```

```js
```

```js
```

```js
```

```js
```