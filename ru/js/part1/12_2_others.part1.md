# Eval: выполнение строки кода

Встроенная функция `eval` позволяет выполнять строку кода.
- Строка кода может быть большой, содержать переводы строк, объявления функций, переменные и т.п.
- Код в eval выполняется в текущем лексическом окружении, поэтому ему доступны внешние переменные.
- В строгом режиме у eval имеется своё лексическое окружение. Поэтому функции и переменные, объявленные внутри eval, нельзя увидеть снаружи.
- Без use strict у eval не будет отдельного лексического окружения, поэтому x и f будут видны из внешнего кода.
```js
let result = eval(code);
```

```js
let code = 'alert("Привет")';
eval(code); // Привет

// напоминание: режим 'use strict' включён по умолчанию во всех исполняемых примерах
eval("let x = 5; function f() {}");
alert(typeof x); // undefined (нет такой переменной)
// функция f тоже невидима
```
## Использование «eval»

В современной разработке на JavaScript eval используется весьма редко. Есть даже известное выражение – «eval is evil» («eval – это зло»).

В этом случае код выполняется в глобальной области видимости:
```js
let x = 1;
{
  let x = 5;
  window.eval('alert(x)'); // 1 (глобальная переменная)
}
```
Если коду внутри eval нужны локальные переменные, поменяйте eval на new Function и передавайте необходимые данные как аргументы.
- Если коду внутри eval нужны локальные переменные, поменяйте eval на new Function и передавайте необходимые данные как аргументы:

# Ссылочный тип

Присмотревшись поближе, в выражении obj.method() можно заметить две операции:
1. Сначала оператор точка '.' возвращает свойство объекта – его метод (obj.method).
2. Затем скобки () вызывают этот метод (исполняется код метода).
- Если мы поместим эти операции в отдельные строки, то значение this, естественно, будет потеряно:
```js
let user = {
  name: "Джон",
  hi() { alert(this.name); },
  bye() { alert("Пока"); }
};
user.hi(); // Джон (простой вызов метода работает хорошо)
// теперь давайте попробуем вызывать user.hi или user.bye
// в зависимости от имени пользователя user.name
(user.name == "Джон" ? user.hi : user.bye)(); // Ошибка!

let user = {
  name: "John",
  hi() { alert(this.name); }
};
// разделим получение метода объекта и его вызов в разных строках
let hi = user.hi;
hi(); // Ошибка, потому что значением this является undefined
```
Здесь `hi = user.hi` сохраняет функцию в переменной, и далее в последней строке она вызывается полностью сама по себе, без объекта, так что нет this.

*Для работы вызовов типа user.hi(), JavaScript использует трюк – точка '.' возвращает не саму функцию, а специальное значение «ссылочного типа», называемого Reference Type.*

Этот ссылочный тип (Reference Type) является внутренним типом. Мы не можем явно использовать его, но он используется внутри языка.

Значение ссылочного типа – это «триплет»: комбинация из трёх значений (base, name, strict), где:
- base – это объект.
- name – это имя свойства объекта.
- strict – это режим исполнения. Является true, если действует строгий режим (use strict).

Результатом доступа к свойству user.hi является не функция, а значение ссылочного типа. Для user.hi в строгом режиме оно будет таким:
```js
// значение ссылочного типа (Reference Type)
(user, "hi", true)
```
Когда скобки () применяются к значению ссылочного типа (происходит вызов), то они получают полную информацию об объекте и его методе, и могут поставить правильный this (user в данном случае, по base).

Ссылочный тип – исключительно внутренний, промежуточный, используемый, чтобы передать информацию от точки . до вызывающих скобок ().

При любой другой операции, например, присваивании hi = user.hi, ссылочный тип заменяется на собственно значение user.hi (функцию), и дальше работа уже идёт только с ней. Поэтому дальнейший вызов происходит уже без this.

Таким образом, значение this передаётся правильно, только если функция вызывается напрямую с использованием синтаксиса точки obj.method() или квадратных скобок obj['method']() (они делают то же самое). Существуют различные способы решения этой проблемы: одним из таких является func.bind().

# BigInt

BigInt – это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.
- В математических операциях мы не можем смешивать bigint и обычные числа.
- Мы должны явно их конвертировать: используя либо BigInt(), либо Number(), например.
- К BigInt числам нельзя применить унарный оператор +
- Операции сравнения, такие как <, >, работают с bigint и обычными числами как обычно.
- В if или любом другом логическом операторе bigint число ведёт себя как обычное число.
- Пожалуйста, обратите внимание, что обычные и bigint числа принадлежат к разным типам, они могут быть равны только при нестрогом сравнении ==.
- Логические операторы ||, && и другие также работают с bigint числами как с обычными числами.
```js
const bigint = 1234567890123456789012345678901234567890n;

const sameBigint = BigInt("1234567890123456789012345678901234567890");

const bigintFromNumber = BigInt(10); // то же самое, что и 10n

alert(1n + 2); // Error: Cannot mix BigInt and other types

alert( 2n > 1n ); // true
alert( 2n > 1 ); // true

alert( 1 == 1n ); // true
alert( 1 === 1n ); // false

if (0n) {
  // никогда не выполнится
}

alert( 1n || 2 ); // 1
alert( 0n || 2 ); // 2
```

# Юникод, внутреннее устройство строк

Как мы уже знаем, строки в JavaScript основаны на Юникоде: каждый символ представляет из себя последовательность байтов из 1-4 байтов.
```js
```

```js
```

```js
```

