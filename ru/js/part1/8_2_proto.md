# Встроенные прототипы

### Object.prototype

`obj = {...}` – это то же самое, что и `obj = new Object()`, где `Object` – встроенная функция-конструктор для объектов с собственным свойством `prototype`, которое ссылается на огромный объект с методом `toString` и другими.
```js
let obj = {};
obj; // "[object Object]" ?

alert(obj.__proto__ === Object.prototype); // true
// obj.toString === obj.__proto__.toString === Object.prototype.toString

alert(Object.prototype.__proto__); // null
```
[Таким образом, когда вызывается obj.toString(), метод берётся из `Object.prototype`.]\
По цепочке прототипов выше `Object.prototype` больше нет свойства `[[Prototype]]`.

При создании массива [1, 2, 3] внутренне используется конструктор массива Array. Поэтому прототипом массива становится `Array.prototype`, предоставляя ему свои методы. Это позволяет эффективно использовать память.\
Согласно спецификации, наверху иерархии встроенных прототипов находится `Object.prototype`. Поэтому иногда говорят, что «всё наследует от объектов».
![](../../../_img/native-prototypes-classes.svg)
```js
let arr = [1, 2, 3];
// наследует ли от Array.prototype?
alert( arr.__proto__ === Array.prototype ); // true
// затем наследует ли от Object.prototype?
alert( arr.__proto__.__proto__ === Object.prototype ); // true
// и null на вершине иерархии
alert( arr.__proto__.__proto__.__proto__ ); // null
```
Некоторые методы в прототипах могут пересекаться, например, у `Array.prototype` есть свой метод `toString`, который выводит элементы массива через запятую.\
Как мы видели ранее, у `Object.prototype` есть свой метод toString, но так как Array.prototype ближе в цепочке прототипов, то берётся именно вариант для массивов.

![](../../../_img/native-prototypes-array-tostring.svg)

[В браузерных инструментах, таких как консоль разработчика, можно посмотреть цепочку наследования (возможно, потребуется использовать `console.dir` для встроенных объектов):]

Другие встроенные объекты устроены аналогично. Даже функции – они объекты встроенного конструктора Function, и все их методы (`call/apply` и другие) берутся из `Function.prototype`. Также у функций есть свой метод `toString`.
```js
function f() {}

alert(f.__proto__ == Function.prototype); // true
alert(f.__proto__.__proto__ == Object.prototype); // true, наследует от Object
```
### Примитивы
[Как мы помним, они не объекты. Но если мы попытаемся получить доступ к их свойствам, то тогда будет создан временный объект-обёртка с использованием встроенных конструкторов `String`, `Number` и `Boolean`, который предоставит методы и после этого исчезнет].\
[Эти объекты создаются невидимо для нас, и большая часть движков оптимизирует этот процесс, но спецификация описывает это именно таким образом.]
Методы этих объектов также находятся в прототипах, доступных как `String.prototype`, `Number.prototype` и `Boolean.prototype`.\
Специальные значения null и undefined стоят особняком. У них нет объектов-обёрток, так что методы и свойства им недоступны. Также у них нет соответствующих прототипов.

### Изменение встроенных прототипов

Встроенные прототипы можно изменять. Например, если добавить метод к `String.prototype`, метод становится доступен для всех строк.
.
```js
String.prototype.show = function() {
  alert(this);
};
"BOOM!".show(); // BOOM!
```
! Прототипы глобальны, поэтому очень легко могут возникнуть конфликты. Если две библиотеки добавляют метод `String.prototype.show`, то одна из них перепишет метод другой. Это считается плохой идеей.

! __В современном программировании есть только один случай, в котором одобряется изменение встроенных прототипов. Это создание полифилов__

__Полифил – это термин, который означает эмуляцию метода, который существует в спецификации JavaScript, но ещё не поддерживается текущим движком JavaScript.__

```js
if (!String.prototype.repeat) { // Если такого метода нет
  String.prototype.repeat = function(n) {
    return new Array(n + 1).join(this);
  };
}

alert( "La".repeat(3) ); // LaLaLa
```
### Заимствование у прототипов

Некоторые методы встроенных прототипов часто одалживают.

[Например, если мы создаём объект, похожий на массив (псевдомассив), мы можем скопировать некоторые методы из Array в этот объект.]
```js
let obj = {
  0: "Hello",
  1: "world!",
  length: 2,
};

obj.join = Array.prototype.join;

alert( obj.join(',') ); // Hello,world!
```
Альтернативная возможность – мы можем унаследовать от массива, установив `obj.__proto__` как `Array.prototype`, таким образом все методы `Array` станут автоматически доступны в obj.\
Но это будет невозможно, если obj уже наследует от другого объекта. Помните, мы можем наследовать только от одного объекта одновременно.

# Методы прототипов, объекты без свойства `__proto__`

Свойство `__proto__` считается устаревшим, и по стандарту оно должно поддерживаться только браузерами.

Современные же методы это:
1. `Object.create(proto[, descriptors])` – создаёт пустой объект со свойством `[[Prototype]]`, указанным как `proto`, и необязательными дескрипторами свойств `descriptors`.
2. `Object.getPrototypeOf(obj)` – возвращает свойство `[[Prototype]]` объекта `obj`.
3. `Object.setPrototypeOf(obj, proto)` – устанавливает свойство `[[Prototype]]` объекта `obj` как `proto`.

```js
let animal = {
  eats: true
};
// создаём новый объект с прототипом animal
let rabbit = Object.create(animal);
rabbit.eats; // true

Object.getPrototypeOf(rabbit) === animal; // получаем прототип объекта rabbit

Object.setPrototypeOf(rabbit, {}); // заменяем прототип объекта rabbit на {}
```
У `Object.create` есть необязательный второй аргумент: дескрипторы свойств. Мы можем добавить дополнительное свойство новому объекту таким образом.
```js
let animal = {
  eats: true
};
let rabbit = Object.create(animal, {
  jumps: {
    value: true
  }
});
alert(rabbit.jumps); // true
```
Мы также можем использовать `Object.create` для «продвинутого» клонирования объекта, более мощного, чем копирование свойств в цикле `for..in`:
```js
// клон obj c тем же прототипом (с поверхностным копированием свойств)
let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
```
Такой вызов создаёт точную копию объекта `obj`, включая все свойства: перечисляемые и неперечисляемые, геттеры/сеттеры для свойств – и всё это с правильным свойством `[[Prototype]]`.

! Изменение прототипа «на лету» с помощью `Object.setPrototypeOf` или `obj.__proto__=` – очень медленная операция, которая ломает внутренние оптимизации для операций доступа к свойствам объекта.

### "Простейший" объект

`Object.create(null)` создаёт пустой объект без прототипа (`[[Prototype]]` будет `null`). Такие объекты можно использовать как «чистые словари», у них нет проблем с использованием строки `__proto__` в качестве ключа.\
Недостаток в том, что у таких объектов не будет встроенных методов объекта, таких как `toString`.\
[Обратите внимание, что большинство методов, связанных с объектами, имеют вид `Object.something(...)`. К примеру, `Object.keys(obj)`. Подобные методы не находятся в прототипе, так что они продолжат работать для таких объектов.]
```js
let obj = Object.create(null);

let key = prompt("What's the key?", "__proto__");
obj[key] = "some value";

obj[key]; // "some value"
alert(obj); // Ошибка (no toString)
Object.keys(chineseDictionary); // hello,bye
```
Ещё методы:
- `Object.keys(obj) / Object.values(obj) / Object.entries(obj)` – возвращают массив всех перечисляемых !собственных! строковых ключей/значений/пар ключ-значение.
- `Object.getOwnPropertySymbols(obj)` – возвращает массив всех собственных символьных ключей.
- `Object.getOwnPropertyNames(obj)` – возвращает массив всех собственных строковых ключей.
- `Reflect.ownKeys(obj)` – возвращает массив всех собственных ключей.
- `obj.hasOwnProperty(key)`: возвращает `true`, если у `obj` есть собственное (не унаследованное) свойство с именем `key`.

```js
```
