# Внешний доступ

Некоторые из ваших компонентов могут нуждаться в управлении и синхронизации с системами за пределами React. Например, вам может понадобиться сфокусировать ввод с помощью API браузера, воспроизвести и поставить на паузу видеоплеер, реализованный без React, или подключиться и прослушать сообщения от удаленного сервера. В этой главе вы познакомитесь с крайними случаями использования, которые позволят вам "выйти за пределы" React и подключиться к внешним системам. Большая часть логики вашего приложения и потока данных не должна полагаться на эти возможности.

## Ссылка на значения с помощью Refs

Когда вы хотите, чтобы компонент "запомнил" какую-то информацию, но не хотите, чтобы эта информация запускала новые рендеры, вы можете использовать ref.

\* Добавление ссылки в ваш компонент\
Вы можете добавить ссылку в свой компонент: внутри вашего компонента вызовите хук useRef и в качестве единственного аргумента передайте начальное значение, на которое вы хотите сослаться.

```tsx
import { useRef } from "react";

function YourComponent() {
  const ref = useRef(0);
}
```

useRef возвращает объект, подобный этому:

```tsx
{
  current: 0; // The value you passed to useRef
}
```

Это значение намеренно мутабельно, то есть вы можете как читать, так и писать в него. Это как секретный карман вашего компонента, который React не отслеживает. (Именно это делает его "запасным выходом" из одностороннего потока данных React - подробнее об этом ниже!)

[exReferenceCounter] нажатие на кнопку _не обновляет ее текст_. Вот почему чтение ref.current во время рендеринга приводит к ненадежному коду. Если вам это нужно, используйте вместо этого state.

Ссылка указывает на число, но, как и state, вы можете указать на что угодно: строку, объект или даже функцию. В отличие от state, ref - это обычный объект JavaScript со свойством current, который можно читать и изменять.

Обратите внимание, что _компонент не перерисовывается при каждом изменении_. Как и state, refs сохраняется React между перерисовками. Однако, установка состояния перерисовывает компонент. Изменение ссылки не делает этого!

[exRefStopwatch]/
Поскольку ID интервала не используется для рендеринга, вы можете хранить его в ссылке.

_Если часть информации нужна только обработчикам событий и ее изменение не требует повторного рендеринга, использование ссылки может быть более эффективным._

\* Различия между refs и state\
Возможно, вы думаете, что ссылки кажутся менее "строгими", чем state - например, вы можете мутировать их вместо того, чтобы всегда использовать функцию установки состояния. Но в большинстве случаев вы захотите использовать state. Рефы - это "аварийный люк", который вам не часто понадобится. Вот как сравниваются state и refs:

1. ref:

- useRef(initialValue) возвращает { current: initialValue }
- Не запускает повторный рендеринг при изменении.
- Mutable - вы можете изменять и обновлять значение current вне процесса рендеринга.
- Вы не должны читать (или записывать) значение current во время рендеринга.

2. state:

- useState(initialValue) возвращает текущее значение переменной состояния и функцию-установщик состояния ( [value, setValue])
- Срабатывает повторный рендеринг при изменении.
- Immutable - вы должны использовать функцию установки состояния для изменения состояния, чтобы поставить в очередь на повторный рендеринг.
- Вы можете читать состояние в любое время. Однако каждый рендер имеет свой собственный snapshot состояния, которое не изменяется.

\* Как useRef работает внутри?\
Хотя и useState и useRef предоставляются React, в принципе useRef может быть реализован поверх useState.\
Во время первого рендеринга useRef возвращает { current: initialValue }. Этот объект хранится в памяти React, поэтому при следующем рендере будет возвращен тот же объект. Обратите внимание, что в этом примере сеттер состояния не используется. Он не нужен, потому что useRef всегда должен возвращать один и тот же объект!  
[Если вы знакомы с объектно-ориентированным программированием, refs может напомнить вам поля экземпляра, но вместо this.something вы напишите somethingRef.current.]

```tsx
// Inside of React
function useRef(initialValue) {
  const [ref, unused] = useState({
    current: initialValue,
  });
  return ref;
}
```

- Но вы можете думать о useRef как об обычной переменной состояния без сеттера.

\* Когда использовать refs\
Как правило, вы используете refs, когда вашему компоненту нужно "выйти за пределы" React и взаимодействовать с внешними API - часто с API браузера, которые не влияют на внешний вид компонента. Вот несколько таких редких ситуаций:

- Хранение идентификаторов таймаута;
- Хранение и манипулирование элементами DOM;
- Хранение других объектов, которые не нужны для вычисления JSX.

Если вашему компоненту нужно хранить какое-то значение, но оно не влияет на логику рендеринга, выбирайте refs.

\* Лучшие практики для refs\

- _Рассматривайте ссылки как аварийный люк_. Ссылки полезны, когда вы работаете с внешними системами или API браузера. Если большая часть логики вашего приложения и потока данных зависит от ссылок, возможно, вам стоит пересмотреть свой подход.
- _Не читайте и не записывайте ref.current во время рендеринга_. Если какая-то информация необходима во время рендеринга, используйте state вместо этого. Поскольку React не знает, когда изменяется ref.current, даже чтение его во время рендеринга делает поведение вашего компонента труднопредсказуемым. (Единственным исключением из этого является код типа if (!ref.current) ref.current = new Thing(), который устанавливает ссылку только один раз во время первого рендеринга).

Ограничения React state не распространяются на refs. Например, состояние действует как снимок для каждого рендера и не обновляется синхронно Но когда вы изменяете текущее значение ссылки, оно немедленно меняется:

```tsx
ref.current = 5;
console.log(ref.current); // 5
```

Это происходит потому, что _ссылка сама по себе является обычным объектом JavaScript_, и поэтому ведет себя как обычный объект.

\* Ссылки и DOM\
Наиболее часто ссылка используется для доступа к элементу DOM. Например, это удобно, если вы хотите программно сфокусировать вход. Когда вы передаете ссылку в атрибут ref в JSX, например <div ref={myRef}>, React помещает соответствующий элемент DOM в myRef.current.

# Манипулирование DOM с помощью Refs

React автоматически обновляет DOM в соответствии с вашим выводом на экран, поэтому вашим компонентам не часто требуется манипулировать им. Однако иногда вам может понадобиться доступ к элементам DOM, управляемым React - например, для фокусировки узла, прокрутки к нему или измерения его размера и положения. Встроенного способа сделать это в React нет, поэтому вам понадобится ref на узел DOM.

\* Получение ссылки на узел\
Когда React создаст DOM-узел для этого <div>, React поместит ссылку на этот узел в myRef.current. Затем вы сможете обращаться к этому узлу DOM из ваших обработчиков событий и использовать встроенные API браузера, определенные на нем.\

Передайте его как <input ref={inputRef}>. Это говорит React ввести DOM-узел этого <input> в inputRef.current.

```tsx
import { useRef } from 'react';

const myRef = useRef(null);

<div ref={myRef}></>

// You can use any browser APIs, for example:
myRef.current.scrollIntoView();
```

\* Доступ к узлам DOM другого компонента\
?[Когда вы помещаете ссылку на встроенный компонент, который выводит элемент браузера, такой как <input />, React установит свойство current этой ссылки на соответствующий узел DOM (такой как фактический <input /> в браузере).]

[exNoReferenceInput]\
Однако если вы попытаетесь поместить ссылку на свой собственный компонент, например <MyInput />, по умолчанию вы получите null.\
Это происходит потому, что _по умолчанию React не позволяет компоненту обращаться к узлам DOM других компонентов_. Ссылки - это запасной выход, который следует использовать в редких случаях. Даже своим собственным детям! Ручное манипулирование DOM-узлами другого компонента делает ваш код еще более хрупким.

```tsx
const inputRef = useRef(null);

<MyInput ref={inputRef} />;
```

Вместо этого, компоненты, которые хотят раскрыть свои узлы DOM, должны согласиться на такое поведение. Компонент может указать, что он "переадресует" свою ссылку одному из своих дочерних компонентов.

forward something (to someone) - переслать что-то (кому-то)

[Вот как MyInput может использовать API forwardRef:]

```tsx
const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});
```

Как это работает:

1. <MyInput ref={inputRef} /> говорит React поместить соответствующий узел DOM в inputRef.current. Однако компонент MyInput должен сам принять это решение - по умолчанию он этого не делает.
2. Компонент MyInput объявлен с использованием forwardRef. Это позволяет ему получать inputRef сверху в качестве второго аргумента ref, который объявляется после props.
3. Сам MyInput передает полученный ref в <input> внутри него.

\* Раскрытие подмножества API с помощью императивного дескриптора
В редких случаях вы можете захотеть ограничить открытую функциональность. Вы можете сделать это с помощью useImperativeHandle [exReferenceImperativeInput].\
Здесь realInputRef внутри MyInput содержит фактический входной DOM-узел. Однако useImperativeHandle инструктирует React предоставлять ваш собственный специальный объект в качестве значения ссылки на родительский компонент. Таким образом, inputRef.current внутри компонента Form будет иметь только метод focus. В этом случае ref "handle" - это не узел DOM, а пользовательский объект, который вы создаете внутри вызова useImperativeHandle.

\* Когда React присоединяет рефы\
В React каждое обновление делится на две фазы:

- Во время render, React вызывает ваши компоненты, чтобы выяснить, что должно быть на экране.
- Во время commit, React применяет изменения в DOM.

В общем, вы не хотите обращаться к рефкам во время рендеринга. Это относится и к ссылкам, содержащим узлы DOM. Во время первого рендеринга узлы DOM еще не были созданы, поэтому ref.current будет null. А во время рендеринга обновлений, узлы DOM еще не были обновлены. Поэтому читать их еще рано.\
React устанавливает ref.current во время фиксации. Перед обновлением DOM, React устанавливает затронутые значения ref.current в null. После обновления DOM, React немедленно устанавливает их в соответствующие узлы DOM.

_Обычно вы обращаетесь к рефкам из обработчиков событий_. Если вы хотите что-то сделать с рефкой, но нет конкретного события, в котором это можно сделать, вам может понадобиться эффект.

[ReferenceTodoList]\
[В React обновления состояния ставятся в очередь. Обычно это то, что вам нужно. Однако здесь это вызывает проблему, потому что setTodos не обновляет DOM немедленно. Поэтому, когда вы прокручиваете список до последнего элемента, todo еще не был добавлен. Поэтому прокрутка всегда "отстает" на один элемент.]

[ReferenceFlashTodoList]\
[Чтобы решить эту проблему, вы можете заставить React обновлять ("промывать") DOM синхронно. Для этого импортируйте flushSync из react-dom и оберните обновление состояния в вызов flushSync.]

```tsx
setTodos([...todos, newTodo]);
listRef.current.lastChild.scrollIntoView();
//
import { flushSync } from "react-dom";

flushSync(() => {
  setTodos([...todos, newTodo]);
});
listRef.current.lastChild.scrollIntoView();
```

\* Избегайте изменения узлов DOM, управляемых React\
[ReferenceWrongWorkWithDOM]\
References/ссылки - это запасной выход. Вы должны их использовать в крайнем случае, только когда вам нужно "выйти за пределы React". Обычные примеры этого - управление фокусом, позицией прокрутки или вызов API браузера, которые React не раскрывает. Однако, если вы попытаетесь изменить DOM вручную, вы рискуете вступить в конфликт с изменениями, которые вносит React.

_Избегайте изменения узлов DOM, управляемых React_

Однако это не означает, что этого нельзя делать вообще. Это требует осторожности. Вы можете _безопасно изменять части DOM, которые у React нет причин обновлять_.

# Синхронизация с эффектами

Некоторые компоненты нуждаются в синхронизации с внешними системами. Например, вы можете захотеть управлять компонентом, не относящимся к React, на основе состояния React, установить соединение с сервером или отправлять журнал аналитики, когда компонент появляется на экране. Эффекты позволяют выполнить некоторый код после рендеринга, чтобы вы могли синхронизировать свой компонент с какой-либо системой вне React.

\* Что такое эффекты и чем они отличаются от событий?\
Есть два типа логики внутри компонентов React:

- _Код рендеринга_ находится на верхнем уровне вашего компонента. Именно здесь вы берете пропсы и состояние, преобразуете их и возвращаете JSX, который вы хотите видеть на экране.
- _Обработчики событий_ - это вложенные функции внутри ваших компонентов, которые делают вещи, а не просто вычисляют их. Обработчик события может обновить поле ввода, отправить HTTP POST-запрос для покупки товара или перевести пользователя на другой экран. Обработчики событий содержат "побочные эффекты" (side effect /saɪd ɪˈfekt/)(они изменяют состояние программы), вызванные определенным действием пользователя (например, нажатием кнопки или набором текста).

[Иногда этого недостаточно. Рассмотрим компонент ChatRoom, который должен подключаться к серверу чата всякий раз, когда он появляется на экране. Подключение к серверу не является чистым вычислением (это побочный эффект), поэтому оно не может происходить во время рендеринга. Однако не существует какого-то конкретного события, например, щелчка мыши, которое вызывает отображение ChatRoom.]\
_Эффекты позволяют указать побочные эффекты, которые вызваны самим рендерингом, а не конкретным событием._ Отправка сообщения в чат - это событие, потому что оно непосредственно вызвано нажатием пользователем определенной кнопки. Однако установка соединения с сервером - это эффект, потому что он должен произойти независимо от того, какое взаимодействие вызвало появление компонента. Эффекты запускаются в конце фазы коммита(commit /kəˈmɪt/) после обновления экрана. Это подходящее время для синхронизации компонентов React с какой-либо внешней системой (например, сетью или сторонней библиотекой).

"Эффект" здесь - побочный эффект, вызванный рендерингом. Для обозначения более широкого понятия программирования - "побочный эффект".

\* Возможно, вам не нужен эффект/
_Не спешите добавлять эффекты в свои компоненты._ Помните, что эффекты обычно используются для того, чтобы "выйти" из кода React и синхронизироваться с какой-либо внешней системой. Если ваш эффект только корректирует одно состояние на основе другого состояния, возможно, вам не нужен эффект.

Три шага объявления эффекта:

1. Объявить эффект.
2. Укажите зависимости эффекта.
3. Добавьте очистку при необходимости.

_useEffect "откладывает" выполнение части кода до тех пор, пока рендеринг не будет отражен на экране._

[EffectVideoDuringRender]\
[У вас может возникнуть соблазн попытаться вызвать play() или pause() во время рендеринга, но это неправильно.]\
!Причина некорректности этого кода в том, что он пытается что-то сделать с узлом DOM во время рендеринга. В React, рендеринг должен быть чистым вычислением JSX и не должен содержать побочных эффектов, таких как изменение DOM.\
!Более того, когда VideoPlayer вызывается в первый раз, его DOM еще не существует! Еще нет узла DOM для вызова play() или pause(), потому что React не знает, какой DOM создавать, пока вы не вернете JSX.\
Решением здесь является _обернуть побочный эффект с помощью useEffect, чтобы переместить его из расчета рендеринга._
[EffectVideo]\
[Обернув обновление DOM в Эффект, вы позволяете React сначала обновить экран. Затем запускается ваш Эффект.\
Когда ваш компонент VideoPlayer отобразится (в первый раз или при повторном рендеринге), произойдет несколько вещей. Во-первых, React обновит экран, убедившись, что тег `<video>` находится в DOM с нужными пропсами. Затем React запустит ваш Эффект. Наконец, ваш Эффект вызовет play() или pause() в зависимости от значения isPlaying.]\
В этом примере "внешней системой", которую вы синхронизировали с состоянием React, был медиа API браузера

!По умолчанию Effects запускаются после каждого рендера. Вот почему код, подобный этому, произведет бесконечный цикл:

```tsx
const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1);
});
```

Эффекты обычно должны синхронизировать ваши компоненты с внешней системой. Если внешней системы нет, и вы хотите только корректировать одно состояние на основе другого состояния, возможно, вам не нужен Эффект.

_По умолчанию эффекты запускаются после каждого рендера._

[exEffectVideoRenderingWithText]\
[Демонстрирует проблему.Обратите внимание, как ввод текста приводит к повторному запуску эффекта.]

React пропустить ненужный _повторный запуск эффекта, указав массив зависимостей в качестве второго аргумента вызова useEffect_.\
_React пропустит повторное выполнение Эффекта только в том случае, если все указанные вами зависимости имеют точно такие же значения, как и во время предыдущего рендеринга._\
React сравнивает значения зависимостей, используя сравнение Object.is.

[exEffectVideoWithText]\

Обратите внимание, что вы не можете "выбирать" свои зависимости. Вы получите ошибку lint, если указанные вами зависимости не соответствуют тому, что ожидает React на основе кода внутри вашего Effect. Если вы не хотите, чтобы какой-то код выполнялся повторно, отредактируйте код самого Эффекта, чтобы он не нуждался в этой зависимости.

```tsx
useEffect(() => {
  // This runs after every render
});

useEffect(() => {
  // This runs only on mount (when the component appears)
}, []);

useEffect(() => {
  // This runs on mount *and also*
  // if either a or b have changed since the last render
}, [a, b]);
```

[exEffectVideoWithText]\
Почему ссылка исключена из массива зависимостей?
[Этот Эффект использует и ref, и isPlaying, но только isPlaying объявлен как зависимость:]

```tsx
function VideoPlayer({ src, isPlaying }) {
const ref = useRef(null);
useEffect(() => {
    if (isPlaying) {
    ref.current.play();
    } else {
    ref.current.pause();
    }
}, [isPlaying]);
```

[Это происходит потому, что объект ref имеет постоянный идентификатор(stable identity): React гарантирует вы всегда будете получать один и тот же объект от одного и того же вызова useRef при каждом рендере. Он никогда не меняется, поэтому сам по себе никогда не вызовет повторного запуска Эффекта. Поэтому не имеет значения, включаете вы его или нет]

_Функции set, возвращаемые useState, также имеют постоянный идентификатор, поэтому их часто можно увидеть опущенными из зависимостей. Если линтер позволяет вам опустить зависимость без ошибок, это безопасно._

[Если ref передается от родительского компонента, вам придется указать его в массиве зависимостей. Почему?]

\* Шаг 3: Добавьте очистку при необходимости\
[exEffectConnection]\

```tsx
export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

Дважды увидев журнал "✅ Connecting...", вы сможете заметить реальную проблему: ваш код не закрывает соединение, когда компонент размонтируется.\
[Представьте, что компонент ChatRoom является частью большого приложения с множеством различных экранов. Пользователь начинает свое путешествие со страницы ChatRoom. Компонент монтируется и вызывает connection.connect(). Затем представьте, что пользователь переходит на другой экран - например, на страницу настроек. Компонент ChatRoom размонтируется. Наконец, пользователь нажимает кнопку Back, и ChatRoom снова монтируется. Это установит второе соединение - но первое соединение никогда не было разрушено! По мере того как пользователь перемещается по приложению, соединения продолжают накапливаться.\
Вы можете отключить Строгий режим, чтобы отказаться от такого поведения при разработке, но мы рекомендуем оставить его включенным. Это позволит вам найти множество ошибок, подобных приведенной выше.]

```tsx
useEffect(() => {
  const connection = createConnection();
  connection.connect();
  return () => {
    connection.disconnect();
  };
}, []);
```

Теперь в процессе разработки вы получите три консольных журнала:

1. "✅ Connecting..."
2. "❌ Disconnected."
3. "✅ Connecting..."

\* Как обрабатывать эффект, срабатывающий дважды в разработке?\
React намеренно перемонтирует ваши компоненты в процессе разработки, чтобы найти ошибки, как в последнем примере. _Правильный вопрос не "как запустить Эффект один раз", а "как исправить мой Эффект, чтобы он работал после перемонтирования"._\
Обычно ответ заключается в реализации функции очистки. Функция очистки должна остановить или отменить все, что делал Эффект. Эмпирическое правило гласит, что пользователь не должен различать однократный запуск Эффекта (как в производстве) и последовательность установка → очистка → установка (как в разработке).\
Большинство эффектов, которые вы будете писать, будут соответствовать одному из общих шаблонов, приведенных ниже...? \* Управление не-React виджетами\

\* Не эффект: инициализация приложения\
Некоторая логика должна выполняться только один раз при запуске приложения. Вы можете поместить ее за пределы ваших компонентов:

```tsx
if (typeof window !== "undefined") {
  // Check if we're running in the browser.
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

!? [exEffectPlayground]\
[Сначала вы увидите три журнала: Schedule "a" log, Cancel "a" log, и Schedule "a" log снова. Через три секунды появится также журнал с надписью a. Как вы узнали ранее, дополнительная пара schedule/cancel нужна потому, что React перемонтирует компонент один раз в процессе разработки, чтобы убедиться, что вы хорошо реализовали очистку.

Теперь отредактируйте входные данные так, чтобы они говорили abc. Если вы сделаете это достаточно быстро, вы увидите Schedule "ab" log, за которым сразу же последуют Cancel "ab" log и Schedule "abc" log. _React всегда очищает эффект предыдущего рендера перед эффектом следующего рендера._ Вот почему, даже если вы быстро вводите данные, за один раз будет запланирован только один тайм-аут. Отредактируйте ввод несколько раз и посмотрите на консоль, чтобы понять, как очищаются эффекты.

Введите что-нибудь в поле ввода, а затем сразу же нажмите "Размонтировать компонент". Обратите внимание, как размонтирование очищает Эффект последнего рендера. Здесь он очищает последний таймаут, прежде чем у него появится шанс сработать.

Наконец, отредактируйте компонент выше и закомментируйте функцию очистки, чтобы таймауты не отменялись. Попробуйте быстро набрать abcde. Что, по вашему мнению, произойдет через три секунды? Будет ли console.log(text) внутри тайм-аута печатать последний текст и выдавать пять логов abcde? Попробуйте, чтобы проверить свою интуицию!

Через три секунды вы должны увидеть последовательность логов (a, ab, abc, abcd и abcde), а не пять логов abcde. Каждый Эффект "захватывает" значение text из соответствующего рендера. Не имеет значения, что состояние text изменилось: Эффект из рендера с text = 'ab' всегда будет видеть 'ab'. Другими словами, эффекты из каждого рендера изолированы друг от друга. Если вам интересно, как это работает, вы можете прочитать о closures.]

! Каждый рендер имеет свои собственные Эффекты\
Вы можете думать об useEffect как о "прикреплении" части поведения к выводу рендера. Рассмотрим этот Эффект:

```tsx
export function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to {roomId}!</h1>;
}
```

Итоги:

- В отличие от событий, эффекты вызываются самим рендерингом, а не конкретным взаимодействием.
- Эффекты позволяют синхронизировать компонент с какой-либо внешней системой (сторонний API, сеть и т.д.).
- По умолчанию эффекты запускаются после каждого рендеринга (включая начальный).
- React пропустит эффект, если все его зависимости имеют те же значения, что и во время последнего рендера.
- Вы не можете "выбрать" свои зависимости. Они определяются кодом внутри Эффекта.
- Пустой массив зависимостей ([]) соответствует "монтированию" компонента, то есть его добавлению на экран.
- В строгом режиме React монтирует компоненты дважды (только в разработке!) для стресс-тестирования ваших Эффектов.
- Если ваш Эффект сломается из-за повторного монтирования, вам необходимо реализовать функцию очистки.
- React будет вызывать вашу функцию очистки перед следующим запуском Эффекта и во время повторного монтирования.

\* Как определить, является ли вычисление дорогим?\
В общем, если вы не создаете тысячи объектов и не выполняете циклы, то, скорее всего, это не дорого. Если вы хотите получить больше уверенности, вы можете добавить консольный журнал, чтобы измерить время, затраченное на часть кода:

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```
