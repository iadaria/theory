# Внешний доступ

Некоторые из ваших компонентов могут нуждаться в управлении и синхронизации с системами за пределами React. Например, вам может понадобиться сфокусировать ввод с помощью API браузера, воспроизвести и поставить на паузу видеоплеер, реализованный без React, или подключиться и прослушать сообщения от удаленного сервера. В этой главе вы познакомитесь с крайними случаями использования, которые позволят вам "выйти за пределы" React и подключиться к внешним системам. Большая часть логики вашего приложения и потока данных не должна полагаться на эти возможности.

## Ссылка на значения с помощью Refs

Когда вы хотите, чтобы компонент "запомнил" какую-то информацию, но не хотите, чтобы эта информация запускала новые рендеры, вы можете использовать ref.

\* Добавление ссылки в ваш компонент\
Вы можете добавить ссылку в свой компонент: внутри вашего компонента вызовите хук useRef и в качестве единственного аргумента передайте начальное значение, на которое вы хотите сослаться.

```tsx
import { useRef } from "react";

function YourComponent() {
  const ref = useRef(0);
}
```

useRef возвращает объект, подобный этому:

```tsx
{
  current: 0; // The value you passed to useRef
}
```

Это значение намеренно мутабельно, то есть вы можете как читать, так и писать в него. Это как секретный карман вашего компонента, который React не отслеживает. (Именно это делает его "запасным выходом" из одностороннего потока данных React - подробнее об этом ниже!)

[exReferenceCounter] нажатие на кнопку _не обновляет ее текст_. Вот почему чтение ref.current во время рендеринга приводит к ненадежному коду. Если вам это нужно, используйте вместо этого state.

Ссылка указывает на число, но, как и state, вы можете указать на что угодно: строку, объект или даже функцию. В отличие от state, ref - это обычный объект JavaScript со свойством current, который можно читать и изменять.

Обратите внимание, что _компонент не перерисовывается при каждом изменении_. Как и state, refs сохраняется React между перерисовками. Однако, установка состояния перерисовывает компонент. Изменение ссылки не делает этого!

[exRefStopwatch]/
Поскольку ID интервала не используется для рендеринга, вы можете хранить его в ссылке.

_Если часть информации нужна только обработчикам событий и ее изменение не требует повторного рендеринга, использование ссылки может быть более эффективным._

\* Различия между refs и state\
Возможно, вы думаете, что ссылки кажутся менее "строгими", чем state - например, вы можете мутировать их вместо того, чтобы всегда использовать функцию установки состояния. Но в большинстве случаев вы захотите использовать state. Рефы - это "аварийный люк", который вам не часто понадобится. Вот как сравниваются state и refs:

1. ref:

- useRef(initialValue) возвращает { current: initialValue }
- Не запускает повторный рендеринг при изменении.
- Mutable - вы можете изменять и обновлять значение current вне процесса рендеринга.
- Вы не должны читать (или записывать) значение current во время рендеринга.

2. state:

- useState(initialValue) возвращает текущее значение переменной состояния и функцию-установщик состояния ( [value, setValue])
- Срабатывает повторный рендеринг при изменении.
- Immutable - вы должны использовать функцию установки состояния для изменения состояния, чтобы поставить в очередь на повторный рендеринг.
- Вы можете читать состояние в любое время. Однако каждый рендер имеет свой собственный snapshot состояния, которое не изменяется.

\* Как useRef работает внутри?\
Хотя и useState и useRef предоставляются React, в принципе useRef может быть реализован поверх useState.\
Во время первого рендеринга useRef возвращает { current: initialValue }. Этот объект хранится в памяти React, поэтому при следующем рендере будет возвращен тот же объект. Обратите внимание, что в этом примере сеттер состояния не используется. Он не нужен, потому что useRef всегда должен возвращать один и тот же объект!  
[Если вы знакомы с объектно-ориентированным программированием, refs может напомнить вам поля экземпляра, но вместо this.something вы напишите somethingRef.current.]

```tsx
// Inside of React
function useRef(initialValue) {
  const [ref, unused] = useState({
    current: initialValue,
  });
  return ref;
}
```

- Но вы можете думать о useRef как об обычной переменной состояния без сеттера.

\* Когда использовать refs\
Как правило, вы используете refs, когда вашему компоненту нужно "выйти за пределы" React и взаимодействовать с внешними API - часто с API браузера, которые не влияют на внешний вид компонента. Вот несколько таких редких ситуаций:

- Хранение идентификаторов таймаута;
- Хранение и манипулирование элементами DOM;
- Хранение других объектов, которые не нужны для вычисления JSX.

Если вашему компоненту нужно хранить какое-то значение, но оно не влияет на логику рендеринга, выбирайте refs.

\* Лучшие практики для refs\

- _Рассматривайте ссылки как аварийный люк_. Ссылки полезны, когда вы работаете с внешними системами или API браузера. Если большая часть логики вашего приложения и потока данных зависит от ссылок, возможно, вам стоит пересмотреть свой подход.
- _Не читайте и не записывайте ref.current во время рендеринга_. Если какая-то информация необходима во время рендеринга, используйте state вместо этого. Поскольку React не знает, когда изменяется ref.current, даже чтение его во время рендеринга делает поведение вашего компонента труднопредсказуемым. (Единственным исключением из этого является код типа if (!ref.current) ref.current = new Thing(), который устанавливает ссылку только один раз во время первого рендеринга).

Ограничения React state не распространяются на refs. Например, состояние действует как снимок для каждого рендера и не обновляется синхронно Но когда вы изменяете текущее значение ссылки, оно немедленно меняется:

```tsx
ref.current = 5;
console.log(ref.current); // 5
```

Это происходит потому, что _ссылка сама по себе является обычным объектом JavaScript_, и поэтому ведет себя как обычный объект.

\* Ссылки и DOM\
Наиболее часто ссылка используется для доступа к элементу DOM. Например, это удобно, если вы хотите программно сфокусировать вход. Когда вы передаете ссылку в атрибут ref в JSX, например <div ref={myRef}>, React помещает соответствующий элемент DOM в myRef.current.

# Манипулирование DOM с помощью Refs

React автоматически обновляет DOM в соответствии с вашим выводом на экран, поэтому вашим компонентам не часто требуется манипулировать им. Однако иногда вам может понадобиться доступ к элементам DOM, управляемым React - например, для фокусировки узла, прокрутки к нему или измерения его размера и положения. Встроенного способа сделать это в React нет, поэтому вам понадобится ref на узел DOM.

\* Получение ссылки на узел\
Когда React создаст DOM-узел для этого <div>, React поместит ссылку на этот узел в myRef.current. Затем вы сможете обращаться к этому узлу DOM из ваших обработчиков событий и использовать встроенные API браузера, определенные на нем.\

Передайте его как <input ref={inputRef}>. Это говорит React ввести DOM-узел этого <input> в inputRef.current.

```tsx
import { useRef } from 'react';

const myRef = useRef(null);

<div ref={myRef}></>

// You can use any browser APIs, for example:
myRef.current.scrollIntoView();
```

\* Доступ к узлам DOM другого компонента\
?[Когда вы помещаете ссылку на встроенный компонент, который выводит элемент браузера, такой как <input />, React установит свойство current этой ссылки на соответствующий узел DOM (такой как фактический <input /> в браузере).]

[exNoReferenceInput]\
Однако если вы попытаетесь поместить ссылку на свой собственный компонент, например <MyInput />, по умолчанию вы получите null.\
Это происходит потому, что _по умолчанию React не позволяет компоненту обращаться к узлам DOM других компонентов_. Ссылки - это запасной выход, который следует использовать в редких случаях. Даже своим собственным детям! Ручное манипулирование DOM-узлами другого компонента делает ваш код еще более хрупким.

```tsx
const inputRef = useRef(null);

<MyInput ref={inputRef} />;
```

Вместо этого, компоненты, которые хотят раскрыть свои узлы DOM, должны согласиться на такое поведение. Компонент может указать, что он "переадресует" свою ссылку одному из своих дочерних компонентов.

forward something (to someone) - переслать что-то (кому-то)

[Вот как MyInput может использовать API forwardRef:]

```tsx
const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});
```

Как это работает:

1. <MyInput ref={inputRef} /> говорит React поместить соответствующий узел DOM в inputRef.current. Однако компонент MyInput должен сам принять это решение - по умолчанию он этого не делает.
2. Компонент MyInput объявлен с использованием forwardRef. Это позволяет ему получать inputRef сверху в качестве второго аргумента ref, который объявляется после props.
3. Сам MyInput передает полученный ref в <input> внутри него.

\* Раскрытие подмножества API с помощью императивного дескриптора
В редких случаях вы можете захотеть ограничить открытую функциональность. Вы можете сделать это с помощью useImperativeHandle [exReferenceImperativeInput].\
Здесь realInputRef внутри MyInput содержит фактический входной DOM-узел. Однако useImperativeHandle инструктирует React предоставлять ваш собственный специальный объект в качестве значения ссылки на родительский компонент. Таким образом, inputRef.current внутри компонента Form будет иметь только метод focus. В этом случае ref "handle" - это не узел DOM, а пользовательский объект, который вы создаете внутри вызова useImperativeHandle.

\* Когда React присоединяет рефы\
В React каждое обновление делится на две фазы:

- Во время render, React вызывает ваши компоненты, чтобы выяснить, что должно быть на экране.
- Во время commit, React применяет изменения в DOM.

В общем, вы не хотите обращаться к рефкам во время рендеринга. Это относится и к ссылкам, содержащим узлы DOM. Во время первого рендеринга узлы DOM еще не были созданы, поэтому ref.current будет null. А во время рендеринга обновлений, узлы DOM еще не были обновлены. Поэтому читать их еще рано.\
React устанавливает ref.current во время фиксации. Перед обновлением DOM, React устанавливает затронутые значения ref.current в null. После обновления DOM, React немедленно устанавливает их в соответствующие узлы DOM.

_Обычно вы обращаетесь к рефкам из обработчиков событий_. Если вы хотите что-то сделать с рефкой, но нет конкретного события, в котором это можно сделать, вам может понадобиться эффект.

[ReferenceTodoList]\
[В React обновления состояния ставятся в очередь. Обычно это то, что вам нужно. Однако здесь это вызывает проблему, потому что setTodos не обновляет DOM немедленно. Поэтому, когда вы прокручиваете список до последнего элемента, todo еще не был добавлен. Поэтому прокрутка всегда "отстает" на один элемент.]

[ReferenceFlashTodoList]\
[Чтобы решить эту проблему, вы можете заставить React обновлять ("промывать") DOM синхронно. Для этого импортируйте flushSync из react-dom и оберните обновление состояния в вызов flushSync.]

```tsx
setTodos([...todos, newTodo]);
listRef.current.lastChild.scrollIntoView();
//
import { flushSync } from "react-dom";

flushSync(() => {
  setTodos([...todos, newTodo]);
});
listRef.current.lastChild.scrollIntoView();
```

\* Избегайте изменения узлов DOM, управляемых React\
[ReferenceWrongWorkWithDOM]\
References/ссылки - это запасной выход. Вы должны их использовать в крайнем случае, только когда вам нужно "выйти за пределы React". Обычные примеры этого - управление фокусом, позицией прокрутки или вызов API браузера, которые React не раскрывает. Однако, если вы попытаетесь изменить DOM вручную, вы рискуете вступить в конфликт с изменениями, которые вносит React.

_Избегайте изменения узлов DOM, управляемых React_

Однако это не означает, что этого нельзя делать вообще. Это требует осторожности. Вы можете _безопасно изменять части DOM, которые у React нет причин обновлять_.

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```
