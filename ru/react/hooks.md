# React Hooks
Хуки позволяют функциональным компонентам React иметь состояние (state) и методы жизненного цикла (lifecycle methods) подобно классовым компонентам. Появление хуков привело к тому в настоящее время классовые компоненты в React почти не используются.

# useState
Хук useState() предназначен для управления состоянием компонента. Данная функция возвращает пару геттер/сеттер - значение начального состояния и функцию для обновления этого значения. Функцию имеет следующую сигнатуру: const [value, setValue] = useState(defaultValue).

# useEffect
Хук `useEffect()` предназначен для запуска побочных эффектов (например, выполнение сетевого запроса или добавление обработчика событий) после монтирования и отрисовки компонента. Данная функция принимает колбек и массив зависимостей. Что касается массива зависимостей, то логика следующая:
- массив не указан: эффект запускается при каждом рендеринге
- указан пустой массив: эффект запускается только один раз
- указан массив с элементами: эффект запускается при изменении любого элемента
Очистка эффектов производится посредством возвращения значений из хука.

Функция имеет следующую сигнатуру:
```js
// обработчик
const handler = () => {
  console.log('Случился клик!')
}

useEffect(() => {
  // запуск эффекта
  window.addEventListener('click', handler)

  // очистка эффекта
  return () => {
    window.removeEventListener('click', handler)
  }
  // массив зависимостей
}, [handler])
```

# useLayoutEffect

Хук `useLayoutEffect()` похож на хук `useEffect()`, за исключением того, что он запускает эффект перед отрисовкой компонента. Данный хук предназначен для запуска эффектов, влияющих на внешний вид `DOM`, незаметно для пользователя. Эта функция имеет такую же сигнатуру, что и `useEffect()`. В подавляющем большинстве случаев для запуска побочных эффектов используется `useEffect()`.

# useContext

Хук `useContext()` предназначен для прямой передачи пропов компонентам, находящимся на любом уровне вложенности. Он позволяет избежать так называемого "бурения пропов" (prop drilling), т.е. необходимости последовательной передачи пропов на каждом уровне вложенности.

```js
// Создание контекста
import { createContext } from 'react'

export const ContextName = createContext()

// Передача контекста нижеследюующим компонентам
<ContextName.Provider value={initialValue}>
  <App />
</ContextName.Provider>

// Получение значения контекста
import { useContext } from 'react'
import { ContextName } from './ContextName'

const contextValue = useContext(ContextName)
```
...TODO examples

# useReducer
Хук `useReducer()`, как и хук `useState()`, предназначен для управления состоянием. Он используется при наличии сложной логики управления состоянием или когда следующее состояние зависит от предыдущего. useReducer() принимает редуктор (reducer), обновляющий состояние на основе типа (type) и, опционально, полезной нагрузки (payload) переданной операции (action).
reducer
reducer [rɪˈdjuːsə] преобразователь

Сигнатура редуктора:
```js
const reducer = (state, action) => {
  switch(action.type) {
    case 'actionType':
      return newState // { value: state.value + action.payload }
    default:
      return state
  }
}
...
// использование хука
const [state, dispatch] = useReducer(reducer, initialState, initFn)
```
# useRef
Хук `useRef()` возвращает объект, свойство `current` которого содержит ссылку на узел DOM. Данный хук также может использоваться для сохранения любого мутирующего значения.
Создание хука: `const node = useRef()`.
Добавление ссылки: `<tagName ref={node}></tagName>`.

See example (IntervalRef)

# Concurrent rendering

Concurrent rendering (конкурентный режим) предназначен для более плавной работы приложения на устройстве пользователя. Одна из областей применения —  прерываемый рендеринг. Представьте, что пользователь вводит в строку поиска текст. Событие обновляет состояние компонента, и происходит рендер нового списка результатов. Во время этого процесса залипает ввод: браузер не может обновить введенный в поле текст, т.к. занимается рендером нового списка результатов. Конкурентный режим исправляет это ограничение и делает рендер прерываемым.

С новыми фичами конкурентного рендеринга были добавлены и новые API: переходы состояния (state transition), фичи задержки (Suspense) и новые хуки.

# startTransition
Метод API добавлен для обновления состояния компонента, которое влечет за собой тяжелые вычисления. Например, фильтрация списка. Это позволяет значительно улучшить пользовательский ввод и отклик интерфейса, т.к. помечает тяжелые обновления компонента как «переходы» — transitions.

В API представлено в виде функции startTransition, в которую помещают обновления состояний, являющихся несрочными — non-urgent.
urgent [ˈɜːʤənt] adj срочный

startTransition полезен, если вы хотите сделать пользовательский ввод быстрым, не было фриза UI, а несрочные операции выполнялись на фоне.
```js
import { startTransition } from 'react';

// Срочное (urgent) обновление: отображаем введенный текст
setInputValue(input);

// Помечаем обновления состояний как переходы
startTransition(() => {
  // Переход: фильтрация списка по введенному ключевому слову
  setSearchQuery(input);
});
```
# useTransition
Помимо startTransition появился новый хук useTransition. Он позволяет узнать статус перехода:
```js
import { useTransition } from 'react';
const [isPending, startTransition] = useTransition();
```

# useDeferredValue
deferred [dɪˈfɜːd] part отсроченный

Вернет отложенную версию переданного значения, которая будет «отставать» от исходной на время, равное таймауту.

Когда полезен новый хук: нужно реализовать отзывчивый и быстрый для пользователя интерфейс. Компонент, с которым взаимодействует пользователь, будет быстро перерисовываться на каждый ввод. При этом не будут происходить лишние перерендеры тяжелого компонента.

useDeferredValue() будет возвращать предыдущее значение до тех пор, пока есть более срочные обновления для завершения и отображения дерева с обновленным значением.
```js
import { useDeferredValue } from 'react';
// ...
const [text, setText] = useState("text");
const deferredText = useDeferredValue(text, { timeoutMs: 2000 });
```

# Улучшения Suspense
suspense [səsˈpens] приостановка

Suspense предназначен для отображения запасного интерфейса (спиннера) во время ожидания дочерних компонентов. Дочерние компоненты в это время могут выполнять асинхронные вызовы API, либо загружаться через lazy load.

Фича приобрела название «Конкурентные задержки» (Concurrent Suspense).Существенное изменение для пользователей заключается в рендере дочерних элементов внутри Suspense.
В React 17 компонент будет смонтирован и вызваны его эффекты. Затем он будет скрыт.
В React 18 компонент смонтируется только после того, как загрузится.
```js
const App = () => {
  return (
    <Suspense>
        <Suspense fallback={<Loading />}>
        <SuspendedComponent />
        <Sibling />
    </Suspense>
  );
};
```
Предназначен для определения порядка, в котором загружаются и отображаются пользователю напрямую вложенные компоненты Suspense и SuspenseList.\
Бывают случаи, когда на UI необходимо отобразить компоненты в определенном порядке. Если обернуть их в ​​SuspenseList, то React не отобразит компонент, пока не загрузится предыдущий из списка.
```js
<SuspenseList revealOrder="forwards">
    <Suspense fallback={'Загрузка...'}>
        <ProfilePicture id={1} />
    </Suspense>
    <Suspense fallback={'Загрузка...'}>
        <ProfilePicture id={2} />
    </Suspense>
    <Suspense fallback={'Загрузка...'}>
        <ProfilePicture id={3} />
    </Suspense>
</SuspenseList>
```

```js
```
```js
```

```js
```
```js
```

```js
```
