Здесь рассмотрим базовые принципы:
1 JSX
2 Elements
3 Components

# 0. React

React — это декларативная, эффективная и гибкая JavaScript библиотека для создания пользовательских интерфейсов.

# 1. JSX

_Это JSX — расширение языка JavaScript._ Объяснить React, как должен выглядеть UI.\
JSX создает «элементы» React. ? элементы рендерятся в DOM ...

_Вместо разделения технологий: логики и разметки в разные файлы, React разделяет ответственность с помощью слабосвязанных единиц - называемых "компоненты", которые содержат и РАЗМЕТКУ, и ЛОГИКУ._\
[Разделение можно увидеть в фреймворках Model-View-Controller: Laravel, ASP.net, - где разделена на логику приложения(код в Controller),пользовательский интерфейс(View, например html шаблоны) и управления данными(бд, например SQL)]

[Ex0_1] Пример объявления переменной

```tsx
const element = <h1>Привет, мир!</h1>;
```

## Встраивание выражений в JSX

JSX допускает использование любых корректных JavaScript-выражений внутри фигурных скобок. Например, `2 + 2`, `user.firstName`

## JSX это тоже выражение

После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.\
Поэтому JSX можно использовать внутри выражений if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.\
[Ex0_2] Пример использования JSX-выражения в выражении if, в качестве возвращаемого значения.

```tsx
function getGreeting(user) {
  if (user) {
    return <h1>Здравствуй, {formatName(user)}!</h1>;
  }
  return <h1>Здравствуй, незнакомец.</h1>;
}
```

## JSX атрибуты

Аттрибуту присваивается либо выражение с помощью фигурных скобок, либо строковый литерал с помощью кавычек.

! Поскольку JSX ближе к JavaScript чем к HTML, React DOM использует стиль именования `camelCase` для свойств вместо обычных имён HTML-атрибутов. Например, `class` становится `className` в JSX.

React DOM экранирует все значения, включенные в JSX перед тем как их отрендерить, предотвращая атаки межсайтовым скриптингом (XSS).[XSS_term]

## JSX - это объекты

Babel компилирует JSX в вызовы `React.createElement()`.
[Ex0_3]Следующие два примера кода эквивалентны между собой:

```tsx
/* JSX */
const element = <h1 className="greeting">Привет, мир!</h1>;
/* JS */
const element = React.createElement(
  "h1",
  { className: "greeting" },
  "Привет, мир!"
);
```

`React.createElement()` создаёт объект похожий на такой:

```tsx
// Примечание: этот код несколько упрощён.
const element = {
  type: "h1",
  props: {
    className: "greeting",
    children: "Привет, мир!",
  },
};
```

Эти объекты называются React-элементами. Элементы — мельчайшие кирпичики React-приложений. Можно сказать, что они описывают результат, который мы хотим увидеть на экране. React читает эти объекты и использует их, чтобы конструировать и поддерживать DOM.

# 1 Элементы

## Рендеринг элементов

В отличие от DOM-элементов, элементы React — это простые объекты, не отнимающие много ресурсов. React DOM обновляет DOM, чтобы он соответствовал переданным React-элементам.\
_Элементы — это то, из чего состоят компоненты_

Допустим, в вашем HTML-файле есть <div>: `<div id="root"></div>`.\
Мы назовём его «корневым» узлом DOM, так как React DOM будет управлять его содержимым.\
Для рендеринга React-элемента в корневой узел DOM, вызовите ReactDOM.render() с React-элементом и корневым DOM узлом в качестве аргументов:

```tsx
const element = <h1>Hello, world</h1>;
ReactDOM.render(element, document.getElementById("root"));
// Получим Hello, world на странице.
```

## Обновление элементов на странице

Элементы React _иммутабельный_. После создания элемента, нельзя изменить его потомков или атрибуты. Элемент похож на кадр в фильме: он отражает состояние интерфейса в конкретный момент времени.\
Пока что, мы знаем только один способ обновить интерфейс — это создать новый элемент и передать его в `ReactDOM.render()`.

[ex0_4] Пример обновления интерфейса с помощью вызова функции для рендеринга элемента.

```tsx
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  // highlight-next-line
  ReactDOM.render(element, document.getElementById("root"));
}

setInterval(tick, 1000);
```

[На практике большинство React-приложений вызывают ReactDOM.render() только один раз.]

## React обновляет только то, что необходимо

React DOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только _минимально необходимые изменения_. [ex0_4]

# 3 Компоненты

Компоненты позволяют разбить интерфейс на независимые части, про которые легко думать в отдельности. Их можно складывать вместе и использовать несколько раз.

Во многом компоненты ведут себя как обычные функции JavaScript. Они принимают произвольные входные данные (так называемые «пропсы») и возвращают React-элементы, описывающие, что мы хотим увидеть на экране. [q1]

Ещё компоненты можно определять как классы ES6:

```tsx
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}
// the same
class Welcome extends React.Component {
  render() {
    return <h1>Привет, {this.props.name}</h1>;
  }
}
```

С точки зрения React, эти два компонента эквивалентны.

## 3.1 Рендеринг компонента

Пока что мы только встречали React-элементы, представляющие собой DOM-теги. Но элементы могут описывать и наши собственные компоненты.

```tsx
const element = <div />;
// Элемент описывает наш собственный компонент
const element = <Welcome name="Алиса" />;
```

React собирает все JSX-аттрибуты в один объект(пропсы) и передает их компоненту.

*Пропсы — это способ передачи данных от родителя к потомку.*

Всегда называйте компоненты с заглавной буквы, иначе React примет его за DOM-тег.

Композиция компонентов: компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет нам использовать одну и ту же абстракцию — компоненты — на любом уровне нашего приложения. \
[На самом верхе у нас обычно компонент App]

Не бойтесь разбивать компонент на части. Чтобы понять извлекать компонент или нет, есть правило: если какая-то часть интерфейса многократно в нём повторяется (Button) или сама по себе достаточно сложная (App), имеет смысл её вынести в независимый компонент. [q2]

- Пропсы можно только читать. _Компонент обязан вести себя как чистая функции по отношению к пропсам_.

# 4 Состояние(state) и жизненный цикл(lifecycle)

«Состояние» очень похоже на пропсы, но оно управляется и доступно только конкретному компоненту.

?!?React группирует несколько вызовов setState() в одно обновление для улучшения производительности.

```tsx
setDate((prev) => prev + 1);
```

## Однонаправленный поток данных

В иерархии компонентов, ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента.\
Состояние часто называют «локальным», «внутренним» или инкапсулированным. Оно доступно только для самого компонента и скрыто от других.

Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов:

```tsx
<Clock date={new Date()}>
```

В свою очередь дочерний компонент не знает откуда они взялись изначально: из состояния родителя, его пропсов или просто выражение.

Этот процесс называется «нисходящим» ("top-down") или «однонаправленным» ("unidirectional") потоком данных.
[ex0_6]

```tsx
function App() {
  return (
    <div>
      <Clock />
      <Clock />
      <Clock />
    </div>
  );
}
ReactDOM.render(<App />, document.getElementById("root"));
```

У каждого компонента Clock есть собственное состояние таймера, которое обновляется независимо от других компонентов.

## Обработка событий

Предотвращаем обработчик события с помощью `preventDefault`.

[ex0_7]

```tsx
function ActionLink() {
  function handleClick(e: React.SyntheticEvent) {
    e.preventDefault();
    console.log("По ссылке кликнули.");
  }

  return (
    <a href="#" onClick={handleClick}>
      Нажми на меня
    </a>
  );
}
```

e — это синтетическое кроссбраузерное событие.

## Предотвращение рендеринга компонента

Компонент может спрятать себя, хотя он уже и отрендерин другими компонентами, вернув null.\
Возврат null из компонента никак не влияет на срабатывание методов жизненного цикла компонентов.

[ex0_8] Пример условного рендеринга и предотвращения рендеринга при условии что warn это false.

```tsx
function WarningBanner(props) {
  if (!props.warn) {
    return null;
  }

  return <div className="warning">Предупреждение!</div>;
}
```

```tsx

```

## 5 Списки и ключи

У каждого элемента массива должен быть ключ (key). «Ключ» – это специальный строковый атрибут, который нужно указывать при создании списка элементов.\
Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.\
Если вы опустите ключ для элемента в списке, то React по умолчанию будет использовать индексы как ключи.\
Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными глобально
[ex0_9]

```tsx
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) => (
  <li key={number.toString()}>{number}</li>
));
```

# Формы

В React HTML-элементы формы ведут себя несколько отлично от остальных DOM-элементов, так как у элементов формы изначально есть внутреннее состояние.
[ex0_10] В эту HTML-форму можно ввести имя:

```tsx
<form>
  <label>
    Имя:
    <input type="text" name="name" />
  </label>
  <input type="submit" value="Отправить" />
</form>
```

Чаще всего форму удобнее обрабатывать с помощью JavaScript-функции, у которой есть доступ к введённым данным. Стандартный способ реализации такого поведения называется «управляемые компоненты».

## Управляемые компоненты

В HTML элементы формы, такие как <input>, <textarea> и <select>, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState().\
Можно скомбинировать оба подхода и сделать состояние React-компонента "единственным источником правды". Значение элемента формы input в этом случае будет контролировать React, а сам элемент будет называться управляемый компонент».
[ex0_11] Используем управляемый компонент
```tsx
const [value, setValue] = useState("");

function handleChange(e: React.BaseSyntheticEvent) {
  setValue(e.target.value);
}

return (
  <form onSubmit={handleSubmit}>
    <input type="text" value={value} onChange={handleChange} />

    <input type="submit" value="Отправить" />
  </form>
);
```

## Подъём состояния

Часто несколько компонентов должны отражать одни и те же изменяющиеся данные. Мы рекомендуем поднимать общее состояние до ближайшего общего предка. Вместо того, чтобы пытаться синхронизировать состояние между различными компонентами, вы должны полагаться на однонаправленный поток данных.

## Композиция против наследования

Некоторые компоненты не знают своих потомков заранее.#
[Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить.]

Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить.

[ex0_12]
```tsx
function FancyBorder(props) {
  return (
    <div
      className={'FancyBorder FancyBorder-' + props.color}
    >
      {props.children}
    </div>
  );
}
function WelcomeDialog() {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">Добро пожаловать</h1>
      <p className="Dialog-message">
        Спасибо, что посетили наш космический корабль!
      </p>
    </FancyBorder>
  )
}

// Другой вариант
function SplitPane(props) {
  return (
    <div className="SplitPane">
      <div className="SplitPane-left">{props.left}</div>
      <div className="SplitPane-right">{props.right}</div>
    </div>
  )
}

function App() {
  return <SplitPane left={<Contacts />} right={<Chat />} />
}
```

# Философия React
Первое, что нужно сделать — представить границы вокруг каждого компонента (и подкомпонента) в макете и дать им имена.\
Принцип единственной ответственности: каждый компонент по-хорошему должен заниматься какой-то одной задачей.\
Если функциональность компонента увеличивается с течением времени, его следует разбить на более мелкие подкомпоненты.
```tsx
```

# Разделение кода
Большинство React-приложений «собирают» свои файлы такими инструментами, как Webpack или Browserify. Сборка (или «бандлинг») — это процесс выявления импортированных файлов и объединения их в один «собранный» файл (часто называемый «bundle» или «бандл»). Этот бандл после подключения на веб-страницу загружает всё приложение за один раз.

Бандлинг это хорошо, но по мере роста вашего приложения, ваш бандл тоже будет расти. Чтобы предотвратить разрастание бандла, стоит начать «разделять» ваш бандл,  создавать несколько бандлов и загружать их по мере необходимости.

Хоть вы и не уменьшите общий объём кода вашего приложения, но избежите загрузки кода, который может никогда не понадобиться пользователю и уменьшите объём кода, необходимый для начальной загрузки.

Лучший способ внедрить разделение кода в приложение — использовать синтаксис динамического импорта: `import()`.

[ex0_13]
```tsx
// До
import { add } from './math'
console.log(add(16, 26))
// После
import('./math').then((math) => {
  console.log(math.add(16, 26))
})
```
Когда Webpack сталкивается с таким синтаксисом, он автоматически начинает разделять код вашего приложения.

Функция React.lazy позволяет рендерить динамический импорт как обычный компонент.\
Она автоматически загрузит бандл содержащий OtherComponent, когда этот компонент будет отрендерен.\
React.lazy принимает функцию, которая должна вызвать динамический import(). Результатом возвращённого Promise является модуль, который экспортирует по умолчанию React-компонент (export default).

[ex0_14]
```tsx
// до
import OtherComponent from './OtherComponent'
// Опосля
const OtherComponent = React.lazy(() =>
  import('./OtherComponent')
)
// Common
function MyComponent() {
  return (
    <div>
      <OtherComponent />
    </div>
  )
}
// Индикатор загрузки
function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Загрузка...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  )
}
```

# Задержка
ы
Если модуль, содержащий OtherComponent, ещё не загружен к моменту рендеринга MyComponent, пока ожидаем, мы должны показать запасное содержимое, например индикатор загрузки. Это можно сделать с помощью компонента Suspense. [ex0_14]\
Проп fallback принимает любой React-элемент, который вы хотите показать, пока происходит загрузка компонента. 

# Разделение кода на основе маршрутов

Часто удобным местом для разделения кода на бандлы являются маршруты. Пользователи привыкли к задержкам во время переходов между страницами. Поэтому и вам может быть выгодно повторно отрендерить всю страницу целиком. 

[ex0_14] Пример разделение кода на основе маршрутов с помощью React.lazy и таких библиотек как React Router.
```tsx
import {
  BrowserRouter as Router,
  Route,
  Switch,
} from 'react-router-dom'
import React, { Suspense, lazy } from 'react'

const Home = lazy(() => import('./routes/Home'))
const About = lazy(() => import('./routes/About'))

const App = () => (
  <Router>
    <Suspense fallback={<div>Загрузка...</div>}>
      <Switch>
        <Route exact path="/" component={Home} />
        <Route path="/about" component={About} />
      </Switch>
    </Suspense>
  </Router>
)
```
# Именованный экспорт
React.lazy в настоящее время поддерживает только экспорт по умолчанию. Если модуль, который требуется импортировать, использует именованный экспорт, можно создать промежуточный модуль, который повторно экспортирует его как модуль по умолчанию. Это гарантирует работоспособность tree shaking — механизма устранения неиспользуемого кода.
```tsx
// ManyComponents.js
export const MyComponent = /* ... */;
export const MyUnusedComponent = /* ... */;
// MyComponent.js
export { MyComponent as default } from './ManyComponents.js'
// MyApp.js
import React, { lazy } from 'react'
const MyComponent = lazy(() => import('./MyComponent.js'))
```

#
```tsx
```

```tsx
```


#
```tsx
```

```tsx
```

#
```tsx
```

```tsx
```


#
```tsx
```

```tsx
```