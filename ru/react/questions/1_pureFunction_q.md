Пример с нарушением правил чистой функции
```ts
let guest = 0;

function Cup() {
    // Плохо: изменение существовавшей переменной!
    guest = guest + 1;
    return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
    return (
        <>
            <Cup />
            <Cup />
            <Cup />
        </>
    );
}

/**
* Result:
    Tea cup for guest #2
    Tea cup for guest #4
    Tea cup for guest #6
 */
```
# Вопрос 1
Почему это нарушение? Что происходит? Расскажите сами на основе 1_pureFunction.

Ответ:
Компонент Cup читает и изменяет переменную объявленную до вызова функции(это функция даже не является параметром, берется извне).
Это приводит к тому, что нарушается второе правило - __каждый вызов компонента будет выдавать разные JSX!__
И более того, если другие компоненты будут читать guest, они тоже будут выдавать разные JSX, в зависимости от того, когда они были вызваны. Получаем непредсказуемый результат.

# Вопрос 2
Как исправить компонент и сделать его чистым?
Ответ - передача guest в качестве параметра.
Почему это будет решением? (Расскажите на основе вышеизложенного)
```ts
function Cup({ guest }) {
    return <h2>Tea cup for guest #{guest}</h2>;
}
export default function TeaSet() {
    return (
        <>
            <Cup guest={1} />
            <Cup guest={2} />
            <Cup guest={3} />
        </>
    );
}
```
Ответ:
- передавая guest в качестве пропса, а не извне, мы соблюдаем чистоту функции, тк чистая функция может принимать параметры
- мы не изменяем переменные созданные до вызова Cut, те guest
- мы получаем один и тот же результат при одних и тех же входных данных - один и тот же JSX. JSX зависит только от пропса quest. 
Итого: функция теперь чистая.

# Вопрос 3
Можем ли мы записывать данные введенные пользователем в обычную переменную?

Ответ: нет. \
Мы не может нарушать первое правило.\
Изменять существующие переменные во время рендеринга компонента.\
Для этого нужно устанавливать состояние, вместо записи в переменную.

# Вопрос 4
Для чего нужен строгий режим?
Как он включается?

Ответ: для проверки не нарушено ли правило 1 чистой функции. 

# Вопрос 5
Этот компонент пытается установить CSS-класс <h1> на night в период с полуночи до шести часов утра, и на day во все остальное время. Однако это не срабатывает. Можете ли вы исправить этот компонент?\
Рендеринг — это вычисление, он не должен пытаться "делать" вещи. Можете ли вы выразить ту же идею по-другому?
```tsx
export default function Clock({ time }) {
    let hours = time.getHours();
    if (hours >= 0 && hours <= 6) {
        document.getElementById('time').className = 'night';
    } else {
        document.getElementById('time').className = 'day';
    }
    return <h1 id="time">{time.toLocaleTimeString()}</h1>;
}
```

Ответ:
Наш компонент должен быть чистой функцией и производить только вычисления, а побочные эффекты не должны происходить во время рендеринга. И мы здесь это нарушаем, мы выполняем побочный эффект( изменение DOМ) в примере выше. В примере ниже - только вычисление и возврат JSX.
```tsx
export default function Clock({ time }) {
    let hours = time.getHours();
    let className = hours >= 0 && hours <= 6 ? 'night' : 'day';
    return (
        <h1 className={className}>
            {time.toLocaleTimeString()}
        </h1>
    );
}
```

```tsx
```

```tsx
```