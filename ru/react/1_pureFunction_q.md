Пример с нарушением правил чистой функции
```ts
let guest = 0;

function Cup() {
    // Плохо: изменение существовавшей переменной!
    guest = guest + 1;
    return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
    return (
        <>
            <Cup />
            <Cup />
            <Cup />
        </>
    );
}

/**
* Result:
    Tea cup for guest #2
    Tea cup for guest #4
    Tea cup for guest #6
 */
```
# Вопрос 1
Почему это нарушение? Что происходит? Расскажите сами на основе 1_pureFunction.

Ответ:
Компонент Cup читает и изменяет переменную объявленную до вызова функции(это функция даже не является параметром, берется извне).
Это приводит к тому, что нарушается второе правило - __каждый вызов компонента будет выдавать разные JSX!__
И более того, если другие компоненты будут читать guest, они тоже будут выдавать разные JSX, в зависимости от того, когда они были вызваны. Получаем непредсказуемый результат.

# Вопрос 2
Как исправить компонент и сделать его чистым?
Ответ - передача guest в качестве параметра.
Почему это будет решением? (Расскажите на основе вышеизложенного)
```ts
function Cup({ guest }) {
    return <h2>Tea cup for guest #{guest}</h2>;
}
export default function TeaSet() {
    return (
        <>
            <Cup guest={1} />
            <Cup guest={2} />
            <Cup guest={3} />
        </>
    );
}
```
Ответ:
- передавая guest в качестве пропса, а не извне, мы соблюдаем чистоту функции, тк чистая функция может принимать параметры
- мы не изменяем переменные созданные до вызова Cut, те guest
- мы получаем один и тот же результат при одних и тех же входных данных - один и тот же JSX. JSX зависит только от пропса quest. 
Итого: функция теперь чистая.
