https://reactdev-ru.pages.dev/learn/reacting-to-input-with-state/#how-declarative-ui-compares-to-imperative

# Управление состоянием

Реагирование на ввод с помощью состояния

?[React предоставляет декларативный способ манипулирования пользовательским интерфейсом. Вместо того чтобы напрямую управлять отдельными частями пользовательского интерфейса, вы описываете различные состояния, в которых может находиться ваш компонент, и переключаетесь между ними в ответ на ввод пользователя. Это похоже на то, как дизайнеры думают о пользовательском интерфейсе.]

## Как декларативный пользовательский интерфейс отличается от императивного

[exImperative] В этом примере императивного программирования пользовательского интерфейса форма построена без React. Она использует только браузерный DOM.

Когда вы проектируете взаимодействие пользовательского интерфейса, вы, вероятно, думаете о том, как пользовательский интерфейс изменяется в ответ на действия пользователя. Рассмотрим форму, которая позволяет пользователю отправить ответ:

1. Когда вы вводите что-то в форму, кнопка "Отправить" становится активной.
2. Когда вы нажимаете кнопку "Отправить", и форма, и кнопка отключаются, и появляется волчок.
3. Если сетевой запрос прошел успешно, форма спрячется, и появится сообщение "Спасибо".
4. Если сетевой запрос не удался, появляется сообщение об ошибке, и форма снова становится открытой.

В _императивном программировании_ вышесказанное прямо соответствует тому, как вы реализуете взаимодействие. Вы должны написать точные инструкции для манипулирования пользовательским интерфейсом в зависимости от того, что только что произошло.\
[Вот еще один способ подумать об этом: представьте, что вы едете рядом с кем-то в машине и говорите ему пошагово, куда ехать.]\
Это называется _императивным_, потому что вы должны _"командовать" каждым элементом_, от спиннера до кнопки, указывая компьютеру как обновить пользовательский интерфейс.

В React вы не управляете пользовательским интерфейсом напрямую - то есть не включаете, не отключаете, не показываете и не скрываете компоненты. Вместо этого вы _заявляете, что вы хотите показать_, а React сам решает, как обновить пользовательский интерфейс

[Вместо того чтобы сказать водителю, куда вы хотите поехать, куда именно повернуть. Это работа водителя - доставить вас туда, и он может даже знать некоторые короткие пути, о которых вы не подумали!]

## Размышления о декларативном интерфейсе

Вы уже видели выше [exImperative], как реализовать форму императивно. Чтобы лучше понять, как мыслить в React, ниже вы пройдете через повторную реализацию этого пользовательского интерфейса в React:

1. Определите различные визуальные состояния вашего компонента
2. Определите, что вызывает изменение состояния.
3. Представьте состояние в памяти с помощью useState.
4. Удалите любые несущественные переменные состояния
5. Подключите обработчики событий для установки состояния

\* 1 шаг
Во-первых, вам нужно представить все различные "состояния" пользовательского интерфейса, которые может увидеть пользователь:

- Пусто: Форма имеет отключенную кнопку "Отправить".
- Типирование: Форма имеет включенную кнопку "Отправить".
- Отправка: Форма полностью отключена. Отображается спиннер.
- Успех: Вместо формы отображается сообщение "Спасибо".
- Ошибка: То же самое, что и состояние типирования, но с дополнительным сообщением об ошибке.
  Как и дизайнеру, вам нужно "смоделировать" или создать "макеты" для различных состояний, прежде чем добавлять логику. Например, здесь показан макет только для визуальной части формы.

```tsx
export default function Form({ status = "empty" }) {
  if (status === "success") {
    return <h1>That's right!</h1>;
  }
  return <h2>City quiz</h2>;
}
```

\* Шаг 2: Определите, что вызывает эти изменения состояния

Вы можете инициировать обновление состояния в ответ на два вида входных данных:

- человеческие входы, такие как нажатие кнопки, ввод текста в поле, переход по ссылке.
- Компьютерные данные, такие как получение ответа от сети, завершение тайм-аута, загрузка изображения.

В обоих случаях вы должны установить переменные состояния для обновления пользовательского интерфейса. Для разрабатываемой вами формы вам нужно будет изменять состояние в ответ на несколько различных входов:

- Изменение текстового ввода (человек) должно переводить его из состояния Empty в состояние Typing или обратно, в зависимости от того, пустое текстовое поле или нет.
- Нажатие кнопки "Отправить " (человек) должно перевести его в состояние Отправить.
- Успешный ответ сети (компьютер) должен перевести его в состояние Успех.
- Неуспешный сетевой ответ (компьютер) должен перевести его в состояние Ошибка с соответствующим сообщением об ошибке.

- Обратите внимание, что человеческий ввод часто требует обработчиков событий!

\* Шаг 3: Представьте состояние в памяти с помощью useState

Простота - это ключ: каждая часть состояния - это "движущаяся часть", и вы хотите как можно меньше "движущихся частей". Больше сложности приводит к большему количеству ошибок!

\* Шаг 4: Удалите все несущественные переменные состояния

\* Шаг 5: Подключите обработчики событий для установки состояния

[exDeclarative]
Хотя этот код длиннее, чем оригинальный императивный пример, он гораздо менее хрупок. _Выражение всех взаимодействий в виде изменений состояния позволяет впоследствии вводить новые визуальные состояния без нарушения существующих_. Это также позволяет изменять то, что должно отображаться в каждом состоянии, не меняя логику самого взаимодействия.

- Декларативное программирование означает описание пользовательского интерфейса для каждого визуального состояния, а не микроменеджмент пользовательского интерфейса (императивное программирование).

[exImperativeTwo] Эта форма переключается между двумя режимами: в режиме редактирования вы видите вводимые данные, а в режиме просмотра - только результат. Метка кнопки меняется между "Редактировать" и "Сохранить" в зависимости от того, в каком режиме вы находитесь. Когда вы изменяете вводимые данные, приветственное сообщение внизу обновляется в режиме реального времени.

Ваша задача - реализовать это на React. [exDeclarativeTwo]

[exDeclarativeTwoWithoutReact] Здесь реализуем декларативный стиль без React.\
Функция updateDOM, которую вы написали, показывает, что React делает под капотом, когда вы устанавливаете состояние. (Однако React также избегает обращения к DOM для свойств, которые не изменились с момента их последней установки).

## Выбор структуры состояния

Правильное структурирование состояния может сделать разницу между компонентом, который приятно модифицировать и отлаживать, и компонентом, который является постоянным источником ошибок.

Правила:

1. Группируйте связанные состояния. Если вы всегда обновляете две или более переменных состояния одновременно, подумайте о том, чтобы объединить их в одну переменную состояния.

```tsx
const [x, setX] = useState(0);
const [y, setY] = useState(0);
// если некоторые две переменные состояния всегда изменяются вместе, хорошей идеей будет объединить их в одну переменную состояния
const [position, setPosition] = useState({ x: 0, y: 0 });
```

2. Избегайте противоречий в состоянии. Когда состояние структурировано таким образом, что несколько частей состояния могут противоречить и "не соглашаться" друг с другом, вы оставляете место для ошибок. Постарайтесь избежать этого.

```tsx
const [isSending, setIsSending] = useState(false);
const [isSent, setIsSent] = useState(false);

async function handleSubmit(e) {
  e.preventDefault();
  setIsSending(true);
  await sendMessage(text);
  setIsSending(false);
  setIsSent(true);
}
// Хотя этот код работает, он оставляет дверь открытой для "невозможных" состояний.
// оказаться в ситуации, когда одновременно isSending и isSent будут true
//  лучше заменить их одной переменной состояния status, которая может принимать одно из трех допустимых состояний: 'typing' (начальное), 'sending' и 'sent':
const [text, setText] = useState("");
const [status, setStatus] = useState("typing");

async function handleSubmit(e) {
  e.preventDefault();
  setStatus("sending");
  await sendMessage(text);
  setStatus("sent");
}

const isSending = status === "sending";
const isSent = status === "sent";
```

3. Если вы можете вычислить какую-то информацию из пропсов компонента или его существующих переменных состояния во время рендеринга, не стоит помещать эту информацию в состояние компонента.

```tsx
// Избыточное состояние
const [firstName, setFirstName] = useState("");
const [lastName, setLastName] = useState("");
const [fullName, setFullName] = useState("");
// Вы всегда можете вычислить fullName из firstName и lastName во время рендеринга, поэтому удалите ее из state..
const fullName = firstName + " " + lastName;
```

Частым примером избыточного состояния является код, подобный этому.\
Здесь переменная состояния color инициализируется параметром messageColor. Проблема в том, что если родительский компонент позже передаст другое значение messageColor (например, 'red' вместо 'blue'), переменная состояния color не будет обновлена! _Состояние инициализируется только во время первого рендеринга._\
Вот почему "зеркальное отражение" какого-либо свойства в переменной состояния может привести к путанице. Вместо этого используйте свойство messageColor непосредственно в коде. Если вы хотите дать ему более короткое имя, используйте константу.\
Таким образом, он не будет рассинхронизирован с пропсом, переданным из родительского компонента.\
"Зеркалирование" пропсов в состояние имеет смысл только тогда, когда вы хотите игнорировать все обновления для конкретного пропса.

```tsx
function Message({ messageColor }) {
  const [color, setColor] = useState(messageColor);
  // надо
  const color = messageColor;
}
```

4. Когда одни и те же данные дублируются в нескольких переменных состояния или во вложенных объектах, их трудно синхронизировать. Сократите дублирование, когда это возможно.

```tsx
const initialItems = [
  { title: "pretzels", id: 0 },
  { title: "crispy seaweed", id: 1 },
  { title: "granola bar", id: 2 },
];
//  содержимое selectedItem является тем же объектом, что и один из элементов списка items. Это означает, что информация о самом элементе дублируется в двух местах.
const [items, setItems] = useState(initialItems);
const [selectedItem, setSelectedItem] = useState(items[0]);
// (В качестве альтернативы можно удерживать выбранный индекс в состоянии).
const [items, setItems] = useState(initialItems);
const [selectedId, setSelectedId] = useState(0);
```

5. Избегайте глубоко вложенного состояния. Глубоко иерархическое состояние не очень удобно для обновления. Когда это возможно, предпочитайте структурировать состояние плоским образом.

Удаление глубоко вложенного места потребует копирования всей цепочки родительских мест. Такой код может быть очень многословным.

_Цель этих принципов - сделать состояние легко обновляемым без ошибок._

## Поднятие состояния вверх

Иногда требуется, чтобы состояние двух компонентов всегда изменялось вместе. Чтобы сделать это, удалите состояние из обоих компонентов, переместите его в их ближайшего общего родителя, а затем передайте его им через props. Передайте обработчики событий, чтобы дочерние компоненты могли изменять состояние родительского.\
Полезно рассматривать компоненты как "управляемые" (управляемые пропсами) или "неуправляемые" (управляемые состоянием).

# Сохранение и сброс состояния

Состояние изолировано между компонентами. React отслеживает, какое состояние принадлежит тому или иному компоненту, основываясь на их месте в дереве пользовательского интерфейса. Вы можете контролировать, когда сохранять состояние, а когда сбрасывать его между повторными рендерами.

\* Дерево пользовательского интерфейса
React также использует древовидные структуры для управления и моделирования пользовательского интерфейса. React создает деревья пользовательского интерфейса из вашего JSX. Затем React DOM обновляет элементы DOM браузера в соответствии с этим деревом пользовательского интерфейса. (React Native переводит эти деревья в элементы, специфичные для мобильных платформ).\
Из компонентов React создает дерево UI, которое React DOM использует для рендеринга DOM.

\* Состояние привязано к позиции в дереве\
Когда вы передаете компоненту состояние, вы можете подумать, что это состояние "живет" внутри компонента. Но на самом деле состояние хранится внутри React. React связывает каждую часть состояния, которую он хранит, с нужным компонентом по тому, где этот компонент находится в дереве пользовательского интерфейса.

```tsx
export default function App() {
  const counter = <Counter />;
  return (
    <div>
      {counter}
      {counter}
    </div>
  );
}
```

\* Дерево React\
Это два отдельных счетчика, потому что каждый из них отображается в своей позиции в дереве.\
В React каждый компонент на экране имеет полностью изолированное состояние.

[ExTreeCounter]
React будет сохранять состояние до тех пор, пока вы рендерите один и тот же компонент в одной и той же позиции. Чтобы увидеть это, увеличьте оба счетчика, затем удалите второй компонент, сняв флажок "Render the second counter", а затем добавьте его обратно.\
когда React удаляет компонент, он уничтожает его состояние.

_React сохраняет состояние компонента до тех пор, пока он отображается в своей позиции в дереве пользовательского интерфейса._ Если компонент удаляется, или другой компонент отображается в той же позиции, React удаляет его состояние.

[ExTreeCounterFancy]\
Когда вы устанавливаете или снимаете флажок, состояние счетчика не сбрасывается. Независимо от того, является ли isFancy true или false, у вас всегда будет `<Counter />` в качестве первого дочернего элемента `div`, возвращаемого из корневого компонента.\
Обновление состояния корневого компонента не сбрасывает Counter, потому что Counter остается в том же положении.\
Это тот же компонент в той же позиции, поэтому с точки зрения React, это тот же счетчик.

Помните, что _для React важна позиция в дереве пользовательского интерфейса, а не в JSX-разметке!_

[ExTreeCounterFancyTwo]\
Этот компонент имеет два предложения return с разными JSX-тегами `<Counter />` внутри и вне if.\
Оба этих тега <Counter /> отображаются в одной и той же позиции. React не знает, где вы размещаете условия в вашей функции. Все, что он "видит" - это дерево, которое вы возвращаете.\
В обоих случаях компонент App возвращает <div> с <Counter /> в качестве первого дочернего элемента. Для React эти два счетчика имеют одинаковый "адрес": первый ребенок первого ребенка корня. Вот как React сопоставляет их между предыдущим и следующим рендерами, независимо от того, как вы структурируете свою логику.

\* Разные компоненты в одной и той же позиции сбрасывают состояние
[ExTreeCounterPaused]\
Здесь вы переключаетесь между различными типами компонентов в одной и той же позиции. Изначально первый дочерний компонент <div> содержал Counter. Но когда вы поменяли местами p, React удалил Counter из дерева пользовательского интерфейса и уничтожил его состояние.\
Когда Counter меняется на p, Counter удаляется, а p добавляется. При обратном переключении p удаляется, а Counter добавляется.

Также, _когда вы отображаете другой компонент в той же позиции, он сбрасывает состояние всего своего поддерева._

Чтобы увидеть, как это работает, увеличьте счетчик, а затем установите флажок[ExTreeCounterFancyThree].\
[Состояние счетчика сбрасывается, когда вы нажимаете на флажок. Хотя вы отображаете Counter, первый ребенок div меняется с div на секцию. Когда дочерний div был удален из DOM, все дерево под ним (включая Counter и его состояние) также было уничтожено.]

Как правило, _если вы хотите сохранить состояние между повторными рендерами, структура дерева должна "совпадать " от одного рендера к другому_.

[exTreeMyComponent]\
[Здесь функция компонента MyTextField определена внутри MyComponent.\
Каждый раз, когда вы нажимаете на кнопку, состояние ввода исчезает! Это происходит потому, что различная функция MyTextField создается для каждого рендера MyComponent. Вы рендерите разный компонент в той же позиции, поэтому React сбрасывает все состояние ниже.]
Это приводит к ошибкам и проблемам с производительностью. Чтобы избежать этой проблемы, _всегда объявляйте функции компонента на верхнем уровне и не вкладывайте их определения_.

\* Сброс состояния в одной и той же позиции\
По умолчанию React сохраняет состояние компонента, пока он остается в той же позиции. Обычно это именно то, что вам нужно, поэтому это имеет смысл как поведение по умолчанию. Но иногда вам может понадобиться сбросить состояние компонента.

[ExTreeScoreboardWrong]\
[В настоящее время, когда вы меняете игрока, счет сохраняется. Два счетчика появляются в одной и той же позиции, поэтому React воспринимает их как один и тот же счетчик, чей параметр персона изменился.
Но концептуально в этом приложении они должны быть двумя отдельными счетчиками. Они могут появляться в одном и том же месте пользовательского интерфейса, но один из них будет счетчиком для Тейлора, а другой - для Сары.]

Есть два способа сбросить состояние при переключении между ними:

1. Рендерить компоненты в разных позициях.
2. Придать каждому компоненту явную идентичность с помощью key.

\* Вариант 1: Рендеринг компонента в разных позициях\
[ExTreeScoreboardRightFirst]\
[Изначально isPlayerA имеет значение true. Поэтому первая позиция содержит состояние Counter, а вторая пуста.Когда вы нажимаете кнопку "Следующий игрок", первая позиция очищается, но вторая теперь содержит Counter.Состояние каждого Counter уничтожается каждый раз, когда он удаляется из DOM. Вот почему они обнуляются каждый раз, когда вы нажимаете на кнопку. Это решение удобно, когда у вас есть только несколько независимых компонентов.]

\* Вариант 2: Сброс состояния с помощью ключа\
Существует и другой, более общий способ сброса состояния компонента.\

Вы могли видеть key при рендеринге списков. Ключи нужны не только для списков! Вы можете использовать ключи, чтобы заставить React различать любые компоненты. По умолчанию React использует порядок внутри родителя ("первый счетчик", "второй счетчик") для различения компонентов. Но ключи позволяют сообщить React, что это не просто первый счетчик или второй счетчик, а конкретный счетчик - например, счетчик Тейлора. Таким образом, React будет знать счетчик Тейлора, где бы он ни появился в дереве!

[exTreeScoreboardRightSecond]\
[В этом примере два <Counter /> не имеют общего состояния, хотя они появляются в одном и том же месте в JSX. При переключении между Тейлором и Сарой состояние не сохраняется. Это происходит потому, что вы дали им разные "ключи". Каждый раз, когда счетчик появляется на экране, создается его состояние. Каждый раз, когда он удаляется, его состояние уничтожается. Переключение между ними сбрасывает их состояние снова и снова.]

- Помните, что ключи не являются глобально уникальными. Они определяют только позицию в пределах родителя.

\* Сброс формы с помощью ключа\
[ExTreeChat]\
[Попробуйте ввести что-нибудь в поле ввода, а затем нажмите "Алиса" или "Боб", чтобы выбрать другого адресата. Вы заметите, что состояние ввода сохраняется, потому что <Chat> отображается в той же позиции в дереве.]

[ExTreeChatRight]\
[Вы же не хотите, чтобы пользователь отправил сообщение, которое он уже набрал, не тому человеку из-за случайного нажатия. Чтобы исправить это, добавьте key в Chat.]

Итого:

- React сохраняет состояние до тех пор, пока один и тот же компонент отображается в одной и той же позиции.
- Состояние не хранится в JSX-тегах. Оно связано с позицией дерева, в которую вы поместили JSX.
- Вы можете заставить поддерево сбросить свое состояние, задав ему другой ключ.
- Не вставляйте определения компонентов, иначе вы случайно сбросите состояние.

# Извлечение логики состояний в Reducer

Компоненты с большим количеством обновлений состояния, распределенных по многим обработчикам событий, могут стать непомерно сложными. В таких случаях вы можете объединить всю логику обновления состояния за пределами вашего компонента в одной функции, называемой редуктором.

Объект, который вы передаете в dispatch, называется "действие":

```tsx
function handleDeleteTask(taskId) {
  dispatch(
    // "action" object:
    {
      type: "deleted",
      id: taskId,
    }
  );
}
```

Объект действия может иметь любую форму.

По общему правилу, принято задавать ему строку type, описывающую произошедшее, и передавать любую дополнительную информацию в других полях.

\* Шаг 2: Напишите функцию-редуктор\
Редукторная функция - это то место, где вы будете размещать логику состояния. Она принимает два аргумента, текущее состояние и объект действия, и возвращает следующее состояние:

```tsx
function yourReducer(state, action) {
  // return next state for React to set
}
```

React установит состояние на то, что вы вернете из редуктора.

Поскольку функция reducer принимает состояние (tasks) в качестве аргумента, вы можете объявить его вне вашего компонента. Это уменьшает уровень отступов и может сделать ваш код более легким для чтения.

```tsx
function tasksReducer(tasks, action) {
  if (action.type === "added") {
    return [
      ...tasks,
      {
        id: action.id,
        text: action.text,
        done: false,
      },
    ];
  } else if (action.type === "changed") {
    return tasks.map((t) => {
      if (t.id === action.task.id) {
        return action.task;
      } else {
        return t;
      }
    });
  } else if (action.type === "deleted") {
    return tasks.filter((t) => t.id !== action.id);
  } else {
    throw Error("Unknown action: " + action.type);
  }
}
```

\* Почему редукторы называются именно так?\
Хотя редукторы могут "уменьшить" количество кода в вашем компоненте, на самом деле они названы в честь операции reduce(), которую вы можете выполнять над массивами.\
Операция reduce() позволяет вам взять массив и "накопить" одно значение из многих:

```tsx
const arr = [1, 2, 3, 4, 5];
const sum = arr.reduce((result, number) => result + number); // 1 + 2 + 3 + 4 + 5
```

Функция, которую вы передаете в reduce, известна как "reducer". Она принимает результат на данный момент и текущий элемент, а затем возвращает следующий результат. React reducers - пример той же идеи: они принимают состояние на данный момент и действие, а возвращают следующее состояние. Таким образом, они накапливают действия со временем в состояние.

[ExReducer/reducer]\
[Вы даже можете использовать метод reduce() с initialState и массивом actions для вычисления конечного состояния, передав ему свою функцию reducer.]

```tsx
import { useReducer } from "react";

//Тогда вы можете заменить useState:
const [tasks, setTasks] = useState(initialTasks);
// с useReducer следующим образом:
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
```

? Хук useReducer похож на useState - вы должны передать ему начальное состояние, а он возвращает значение состояния и способ установки состояния (в данном случае функцию диспетчеризации). Но он немного отличается.

Хук useReducer принимает два аргумента:

1. Функция редуктора
2. Начальное состояние
   И возвращает:
3. Значение с состоянием
4. Диспетчерская функция (для "отправки" действий пользователя на редуктор).

Логику компонентов легче читать, когда вы разделяете проблемы подобным образом. Теперь обработчики событий только определяют что произошло, отправляя действия, а функция reducer определяет как обновляется состояние в ответ на них.

\* Правильное написание редукторов\

- Редукторы должны быть чистыми. Подобно функциям обновления состояния, редукторы работают во время рендеринга! (Действия ставятся в очередь до следующего рендера.) Это означает, что редукторы должны быть чистыми - одинаковые входы всегда приводят к одинаковому выходу. Они не должны посылать запросы, планировать таймауты или выполнять какие-либо побочные эффекты (операции, которые влияют на вещи за пределами компонента). Они должны обновлять объекты и массивы без мутаций.
- Каждое действие описывает одно взаимодействие пользователя, даже если оно приводит к нескольким изменениям данных. Например, если пользователь нажимает кнопку "Reset" на форме с пятью полями, управляемыми редуктором, логичнее отправить одно действие reset_form, чем пять отдельных действий set_field. Если вы регистрируете каждое действие в редукторе, этот журнал должен быть достаточно ясным, чтобы вы могли восстановить, какие взаимодействия или ответы происходили в каком порядке. Это помогает при отладке.

# Context

## Глубокая передача данных с помощью контекста

Обычно вы передаете информацию от родительского компонента к дочернему компоненту с помощью пропсов. Но передача пропсов может стать многословной и неудобной, если вам приходится передавать их через множество компонентов в середине, или если многим компонентам в вашем приложении нужна одна и та же информация. Контекст позволяет родительскому компоненту сделать некоторую информацию доступной для любого компонента в дереве под ним - независимо от глубины - без явной передачи ее через параметры.

_Поднятие состояния_ вверх так высоко может привести к ситуации, называемой "prop drilling".

\* Контекст: альтернатива передаче props\
Контекст позволяет родительскому компоненту предоставлять данные всему дереву под ним.

[exNoContextPage] Пример без контекста. В настоящее время вы передаете параметр level каждому <Heading> отдельно.\
[Было бы неплохо, если бы вы могли передавать параметр level компоненту <Section> и удалять его из <Heading>. Таким образом можно было бы добиться того, чтобы все заголовки в одном разделе имели одинаковый размер]

Для этого нужно, чтобы дочерний компонент мог "запрашивать" данные откуда-то сверху в дереве.\
Контекст позволяет родителю - даже очень далекому - предоставлять некоторые данные всему дереву внутри него.\
[exContextPage]
useContext сообщает React, что компонент Heading хочет прочитать LevelContext.\
В настоящее время вы все еще должны указывать параметр level каждой секции вручную. Поскольку контекст позволяет вам читать информацию из компонента выше, каждый Section мог бы читать level из Section выше, и передавать level + 1 вниз автоматически. [exContextPageTwo]

В этом примере используются уровни заголовков, потому что они наглядно показывают, как вложенные компоненты могут переопределять контекст. Но контекст полезен и во многих других случаях. Вы можете передать любую информацию, необходимую всему поддереву: текущую цветовую тему, пользователя, вошедшего в систему, и так далее.

_Контекст позволяет вам писать компоненты, которые "адаптируются к окружению" и отображаются по-разному в зависимости от того, где (или, другими словами, в каком контексте) они отображаются._

Примеры использования контекста: тематика, текущая учетная запись, маршрутизация, управление состоянием.

?[Итого:
Итого

- Контекст позволяет компоненту предоставлять некоторую информацию всему дереву под ним.
- Чтобы передать контекст:
  -- Создайте и экспортируйте его с помощью export const MyContext = createContext(defaultValue).
  -- Передайте его в хук useContext(MyContext), чтобы прочитать его в любом дочернем компоненте, независимо от его глубины.
  -- Заверните дочерние компоненты в <MyContext.Provider value={...}>, чтобы предоставить его от родителя.
- Контекст проходит через любые компоненты в середине.
- Контекст позволяет вам писать компоненты, которые "адаптируются к своему окружению".
- Прежде чем использовать контекст, попробуйте передать props или передать JSX в качестве children]

[taskContext]

# Расширение с помощью редуктора и контекста

```tsx

```

````tsx


#

```tsx

````

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```
