https://reactdev-ru.pages.dev/learn/reacting-to-input-with-state/#how-declarative-ui-compares-to-imperative

# Управление состоянием

Реагирование на ввод с помощью состояния

?[React предоставляет декларативный способ манипулирования пользовательским интерфейсом. Вместо того чтобы напрямую управлять отдельными частями пользовательского интерфейса, вы описываете различные состояния, в которых может находиться ваш компонент, и переключаетесь между ними в ответ на ввод пользователя. Это похоже на то, как дизайнеры думают о пользовательском интерфейсе.]

## Как декларативный пользовательский интерфейс отличается от императивного

[exImperative] В этом примере императивного программирования пользовательского интерфейса форма построена без React. Она использует только браузерный DOM.

Когда вы проектируете взаимодействие пользовательского интерфейса, вы, вероятно, думаете о том, как пользовательский интерфейс изменяется в ответ на действия пользователя. Рассмотрим форму, которая позволяет пользователю отправить ответ:

1. Когда вы вводите что-то в форму, кнопка "Отправить" становится активной.
2. Когда вы нажимаете кнопку "Отправить", и форма, и кнопка отключаются, и появляется волчок.
3. Если сетевой запрос прошел успешно, форма спрячется, и появится сообщение "Спасибо".
4. Если сетевой запрос не удался, появляется сообщение об ошибке, и форма снова становится открытой.

В _императивном программировании_ вышесказанное прямо соответствует тому, как вы реализуете взаимодействие. Вы должны написать точные инструкции для манипулирования пользовательским интерфейсом в зависимости от того, что только что произошло.\
[Вот еще один способ подумать об этом: представьте, что вы едете рядом с кем-то в машине и говорите ему пошагово, куда ехать.]\
Это называется _императивным_, потому что вы должны _"командовать" каждым элементом_, от спиннера до кнопки, указывая компьютеру как обновить пользовательский интерфейс.

В React вы не управляете пользовательским интерфейсом напрямую - то есть не включаете, не отключаете, не показываете и не скрываете компоненты. Вместо этого вы _заявляете, что вы хотите показать_, а React сам решает, как обновить пользовательский интерфейс

[Вместо того чтобы сказать водителю, куда вы хотите поехать, куда именно повернуть. Это работа водителя - доставить вас туда, и он может даже знать некоторые короткие пути, о которых вы не подумали!]

## Размышления о декларативном интерфейсе

Вы уже видели выше [exImperative], как реализовать форму императивно. Чтобы лучше понять, как мыслить в React, ниже вы пройдете через повторную реализацию этого пользовательского интерфейса в React:

1. Определите различные визуальные состояния вашего компонента
2. Определите, что вызывает изменение состояния.
3. Представьте состояние в памяти с помощью useState.
4. Удалите любые несущественные переменные состояния
5. Подключите обработчики событий для установки состояния

\* 1 шаг
Во-первых, вам нужно представить все различные "состояния" пользовательского интерфейса, которые может увидеть пользователь:

- Пусто: Форма имеет отключенную кнопку "Отправить".
- Типирование: Форма имеет включенную кнопку "Отправить".
- Отправка: Форма полностью отключена. Отображается спиннер.
- Успех: Вместо формы отображается сообщение "Спасибо".
- Ошибка: То же самое, что и состояние типирования, но с дополнительным сообщением об ошибке.
  Как и дизайнеру, вам нужно "смоделировать" или создать "макеты" для различных состояний, прежде чем добавлять логику. Например, здесь показан макет только для визуальной части формы.

```tsx
export default function Form({ status = "empty" }) {
  if (status === "success") {
    return <h1>That's right!</h1>;
  }
  return <h2>City quiz</h2>;
}
```

\* Шаг 2: Определите, что вызывает эти изменения состояния

Вы можете инициировать обновление состояния в ответ на два вида входных данных:

- человеческие входы, такие как нажатие кнопки, ввод текста в поле, переход по ссылке.
- Компьютерные данные, такие как получение ответа от сети, завершение тайм-аута, загрузка изображения.

В обоих случаях вы должны установить переменные состояния для обновления пользовательского интерфейса. Для разрабатываемой вами формы вам нужно будет изменять состояние в ответ на несколько различных входов:

- Изменение текстового ввода (человек) должно переводить его из состояния Empty в состояние Typing или обратно, в зависимости от того, пустое текстовое поле или нет.
- Нажатие кнопки "Отправить " (человек) должно перевести его в состояние Отправить.
- Успешный ответ сети (компьютер) должен перевести его в состояние Успех.
- Неуспешный сетевой ответ (компьютер) должен перевести его в состояние Ошибка с соответствующим сообщением об ошибке.

- Обратите внимание, что человеческий ввод часто требует обработчиков событий!

\* Шаг 3: Представьте состояние в памяти с помощью useState

Простота - это ключ: каждая часть состояния - это "движущаяся часть", и вы хотите как можно меньше "движущихся частей". Больше сложности приводит к большему количеству ошибок!

\* Шаг 4: Удалите все несущественные переменные состояния

\* Шаг 5: Подключите обработчики событий для установки состояния

[exDeclarative]
Хотя этот код длиннее, чем оригинальный императивный пример, он гораздо менее хрупок. _Выражение всех взаимодействий в виде изменений состояния позволяет впоследствии вводить новые визуальные состояния без нарушения существующих_. Это также позволяет изменять то, что должно отображаться в каждом состоянии, не меняя логику самого взаимодействия.

- Декларативное программирование означает описание пользовательского интерфейса для каждого визуального состояния, а не микроменеджмент пользовательского интерфейса (императивное программирование).

[exImperativeTwo] Эта форма переключается между двумя режимами: в режиме редактирования вы видите вводимые данные, а в режиме просмотра - только результат. Метка кнопки меняется между "Редактировать" и "Сохранить" в зависимости от того, в каком режиме вы находитесь. Когда вы изменяете вводимые данные, приветственное сообщение внизу обновляется в режиме реального времени.

Ваша задача - реализовать это на React. [exDeclarativeTwo]

[exDeclarativeTwoWithoutReact] Здесь реализуем декларативный стиль без React.\
Функция updateDOM, которую вы написали, показывает, что React делает под капотом, когда вы устанавливаете состояние. (Однако React также избегает обращения к DOM для свойств, которые не изменились с момента их последней установки).

## Выбор структуры состояния

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```

#

```tsx

```

```tsx

```

```tsx

```
