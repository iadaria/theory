#

Некоторые элементы на экране обновляются в ответ на ввод пользователя. В React данные, которые изменяются со временем, называются состояние. Вы можете добавить состояние в любой компонент и обновлять его по мере необходимости. В этой главе вы узнаете, как писать компоненты, которые обрабатывают взаимодействия, обновляют свое состояние и отображают различные результаты с течением времени.

React позволяет добавлять обработчики событий в JSX. Обработчики событий - это ваши собственные функции, которые будут запускаться в ответ на действия пользователя, такие как нажатие, наведение курсора, фокусировка на вводе формы и так далее.

# Состояние: память компонента

Компоненты часто нуждаются в изменении того, что отображается на экране в результате взаимодействия.\
Ввод текста в форму должен обновить поле ввода, нажатие кнопки "next" на карусели изображений должно изменить отображаемое изображение, нажатие кнопки "buy" помещает товар в корзину. Компоненты должны "запоминать" вещи: текущее значение ввода, текущее изображение, корзину. В React такая память, специфичная для компонента, называется state..

[Вы можете добавить состояние в компонент с помощью хука useState.\
Он принимает начальное состояние и возвращает пару значений: текущее состояние и функцию-установщик состояния, которая позволяет вам обновить его.]

# Рендеринг и фиксация

Прежде чем ваши компоненты будут отображены на экране, они должны быть отрендерены React.
Этот процесс запроса и подачи пользовательского интерфейса состоит из трех этапов:

1. Триггер рендеринга (доставка заказа посетителя на кухню).
2. Рендеринг компонента (подготовка заказа на кухне)
3. Коммитирование в DOM (размещение заказа на столе)

# Состояние как моментальный снимок

В отличие от обычных переменных JavaScript, состояние в React ведет себя скорее как моментальный снимок. Его установка не изменяет уже имеющуюся переменную state, а вместо этого вызывает повторный рендеринг.\
! Такое поведение поможет вам избежать мелких ошибок.

[StateFormEx11]

```tsx
console.log(count); // 0
setCount(count + 1); // Request a re-render with 1
console.log(count); // Still 0!
```

[StateCounterEx12]\
Состояние как моментальный снимок объясняет, почему это происходит. Установка состояния запрашивает новый рендеринг, но не изменяет его в уже запущенном коде. Поэтому score продолжает быть 0 сразу после вызова setScore(score + 1).

```tsx
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
```

Можно исправить с помощью: setScore(score + 1) на setScore(s => s + 1). _Это позволяет поставить в очередь несколько обновлений состояния._

```tsx

```

```tsx

```

```tsx

```

# Обновление объектов в состоянии

Если у нас состояние в виде объекта, то мы не должны менять этот объект хранящийся в состоянии напрямую, мы должны создать новый(или сделать копию), а затем обновить состояние с помощью этой копии. Обычно используется оператор расширения(...)

```tsx
const [person, setPerson] = useState({
  name: "Niki de Saint Phalle",
  artwork: {
    title: "Blue Nana",
    city: "Hamburg",
    image: "https://i.imgur.com/Sd1AgUOm.jpg",
  },
});

function handleNameChange(e) {
  setPerson({
    ...person,
    name: e.target.value,
  });
}
```

```tsx

```

```tsx

```

```tsx

```

# Обновление массивов в состоянии

Как и с объектами, мы создаем новый массив для обновления состояния, а не изменяем старый, который доступен только для чтения.

# Реакция на события

React позволяет добавлять обработчики событий в JSX. Обработчики событий — это ваши собственные функции, которые будут запускаться в ответ на такие взаимодействия, как нажатие, наведение курсора, фокусировка ввода формы и так далее.

\*Добавление обработчика:\
Чтобы добавить обработчик событий, вы сначала определите функцию, а затем передадите ее как параметр в соответствующий JSX тег.

- По традиции, принято называть обработчики событий handle, за которым следует имя события.

```tsx
export default function Button() {
  // handleClick - обработчик события
  function handleClick() {
    alert("You clicked me!");
  }

  return <button onClick={handleClick}>Click me</button>;
}
```

- Чтение пропсов в обработчиках событий\
  Поскольку обработчики событий объявлены внутри компонента, они имеют доступ к пропсам компонента.

* По соглашению, пропсы обработчиков событий должны начинаться с on, за которым следует заглавная буква.

```tsx
function Button({ onSmash, children }) {
  return <button onClick={onSmash}>{children}</button>;
}

export function App() {
  return (
    <div>
      <Button onSmash={() => alert("Playing!")}>Play Movie</Button>
    </div>
  );
}
```

- Распространение событий\
  Обработчики событий также будут улавливать события от всех дочерних компонентов, которые могут быть у вашего компонента. Мы говорим, что событие "бурлит" или "распространяется" вверх по дереву: оно начинается с того места, где произошло событие, а затем поднимается вверх по дереву.

* Все события распространяются в React, кроме onScroll, которое действует только на тег JSX, к которому вы его прикрепили.

[EventPopingEx13] [Если вы нажмете на любую из кнопок, сначала сработает ее onClick, а затем onClick родительской <div>. Таким образом, появятся два сообщения. Если щелкнуть на самой панели инструментов, то будет запущена только onClick родительской <div>.]

- Остановка распространения\
  Обработчики событий получают объект event в качестве единственного аргумента. По традиции он обычно называется e, что означает "событие". Вы можете использовать этот объект для чтения информации о событии.\
  Этот объект события также позволяет остановить распространение. Если вы хотите, чтобы событие не достигло родительских компонентов, вам нужно вызвать e.stopPropagation().\
  В редких случаях вам может понадобиться перехватить все события на дочерних элементах, даже если они прекратили распространение. Например, вы хотите регистрировать каждый клик в аналитике, независимо от логики распространения. Вы можете сделать это, добавив Capture в конце имени события.

```tsx
/*
Каждое событие распространяется в три фазы:
1. Оно перемещается вниз, вызывая все обработчики onClickCapture.
2. Запускается обработчик onClick щелкнутого элемента.
3. Он перемещается вверх, вызывая все обработчики onClick.

*/
<div
  onClickCapture={() => {
    /* this runs first */
  }}
>
  <button onClick={(e) => e.stopPropagation()} />
  <button onClick={(e) => e.stopPropagation()} />
</div>
```

# Предотвращение поведения по умолчанию

Некоторые события браузера имеют поведение по умолчанию.
[Например, событие отправки <form>, которое происходит при нажатии на кнопку внутри него, по умолчанию перезагружает всю страницу]\
Можем предотвратить такое поведение вызовом e.preventDefault().

```ts
export default function Signup() {
  return (
    <form
      onSubmit={(e) => {
        // e.preventDefault();
        alert("Submitting!");
      }}
    >
      <input />
      <button>Send</button>
    </form>
  );
}
```

Не путаем:

- e.stopPropagation() останавливает срабатывание обработчиков событий, прикрепленных к вышеуказанным тегам.
- e.preventDefault() предотвращает поведение браузера по умолчанию для тех немногих событий, в которых он есть.

! Обработчики событий - лучшее место для побочных эффектов.\
[В отличие от функций рендеринга, обработчики событий не обязаны быть чистыми, поэтому это отличное место для изменения чего-либо - например, изменения значения ввода в ответ на ввод текста или изменения списка в ответ на нажатие кнопки. Однако для того, чтобы изменить какую-то информацию, вам сначала нужно каким-то образом ее сохранить. В React для этого используется state, память компонента.]

```ts

```

# Состояние: память компонента

Компоненты часто должны изменять то, что отображается на экране в результате взаимодействия.\
[нажатие кнопки "buy" должно поместить товар в корзину]

Когда обычной переменной недостаточно:\
Обработчик события handleClick обновляет локальную переменную index [StateGalleryEx43]. \
Но мы не видим изменения:

_1. Локальные переменные не сохраняются между рендерами._\
[? Когда React рендерит этот компонент во второй раз, он рендерит его с нуля - он не учитывает никаких изменений в локальных переменных.]
_2. Изменения локальных переменных не вызывают рендеринга._

```ts
import { sculptureList } from "./data.js";

export default function Gallery() {
  let index = 0;

  function handleClick() {
    index = index + 1;
  }

  return <>...</>;
}
```

Чтобы обновить компонент новыми данными, должны произойти две вещи:

1. Данные между рендерами должны быть сохранены.\
   [В случае локальной переменной этого не происходит, она сбрасывается [ex43]]
2. _Триггер_ React для рендеринга компонента с новыми данными (повторный рендеринг).
   [В случае изменения локальной переменной он не срабатывает [ex43]]

Хук useState обеспечивает эти две вещи:

- state сохраняется между рендерами;
- функция state setter для обновления переменной запускает повторный рендер компонента;

Синтаксис [ и ] здесь называется деструктуризация массива.

?! Хуки - это специальные функции, которые доступны только во время рендеринга. Они позволяют вам "подключаться" к различным возможностям React.

## Анатомия useState

Когда вы вызываете useState, вы говорите React, что хотите, чтобы этот компонент что-то запомнил:\
[В данном случае вы хотите, чтобы React запомнил index.]

```ts
const [index, setIndex] = useState(0);
```

Единственным аргументом для useState является **инициализирующее значение** вашей переменной состояния.

При каждом рендеринге компонента useState выдает массив, содержащий два значения:

1. Переменная state (index) со значением, которое вы сохранили.
2. Функция установки состояния (setIndex), которая может обновить переменную состояния и вызвать React для повторного рендеринга компонента.

Этот пример не использует React, но он дает представление о том, как useState работает внутри [exHook]

\*Состояние изолированное и частное

_Если вы дважды отобразите один и тот же компонент, каждая копия будет иметь полностью изолированное состояние!_ Изменение одного из них не повлияет на другой.\
В отличие от props, state является полностью приватным для объявляющего его компонента.

Что если вы хотите, чтобы обе галереи синхронизировали свои состояния? Правильный способ сделать это в React - удалить состояние из дочерних компонентов и добавить его в их ближайший общий родительский компонент.

# Render и Commit

Прежде чем ваши компоненты будут отображены на экране, они должны быть отрисованы React.
Этот процесс запроса и подачи пользовательского интерфейса состоит из трех этапов:

1. Триггирование рендеринга
2. Рендеринг компонента
3. Коммитирование в DOM

\* Запуск рендеринга\
Есть две причины для рендеринга компонента:

1. Это начальный рендеринг компонента.
2. Состояние компонента (или одного из его предков) было обновлено.

\* Начальный рендер\
Когда ваше приложение запускается, вам необходимо вызвать начальный рендеринг. Фреймворки и песочницы иногда скрывают этот код, но он выполняется вызовом createRoot с целевым узлом DOM, а затем вызовом его метода render с вашим компонентом:

```ts
import Image from "./Image.js";
import { createRoot } from "react-dom/client";

const root = createRoot(document.getElementById("root"));
root.render(<Image />);
```

\* Рендеринг при обновлении состояния\
После того, как компонент был первоначально отрисован, вы можете инициировать дальнейшие рендеры, обновляя его состояние с помощью функции set. Обновление состояния компонента автоматически ставит его в очередь на рендер.

\* Шаг 2. React рендерит ваши компоненты
После запуска рендеринга React вызывает ваши компоненты, чтобы определить, что отобразить на экране. _"Рендеринг" - это обращение React к вашим компонентам._

- При первом рендере React вызывает корневой компонент.
- При последующих рендерах React будет вызывать функциональный компонент, обновление состояния которого вызвало рендер.

Этот процесс рекурсивен: если обновленный компонент возвращает какой-то другой компонент, React будет рендерить этот компонент следующим, и если этот компонент тоже что-то возвращает, он будет рендерить этот компонент следующим, и так далее. Этот процесс будет продолжаться до тех пор, пока не останется вложенных компонентов и React не будет точно знать, что должно быть отображено на экране.

- Во время первоначального рендеринга React создаст DOM-узлы для тегов <section>, <h1> и трех <img>.
- Во время повторного рендеринга React вычислит, какие из их свойств, если таковые имеются, изменились с момента предыдущего рендеринга. Он ничего не будет делать с этой информацией до следующего шага, фазы фиксации.

! Рендеринг всегда должен быть чистым вычислением:

- Одинаковые параметры, одинаковый результат. При одинаковых параметрах компонент всегда должен возвращать одинаковый JSX.
- Он занимается своими делами. Он не должен изменять никакие объекты или переменные, существовавшие до рендеринга.

\* Шаг 3: React фиксирует изменения в DOM

После рендеринга (вызова) ваших компонентов React изменит DOM.

- Для первоначального рендеринга, React будет использовать appendChild() DOM API для размещения всех созданных им узлов DOM на экране.
- Для повторного рендеринга, React будет применять минимально необходимые операции (вычисляемые во время рендеринга!), чтобы DOM соответствовал последнему выводу рендеринга.

! React изменяет узлы DOM, только если есть разница между рендерами.

\* Браузерная отрисовка\
После того как рендеринг завершен и React обновил DOM, браузер перерисовывает экран. Хотя этот процесс известен как "браузерный рендеринг", мы будем называть его "рисованием", чтобы избежать путаницы в документации.

! React не трогает DOM, если результат рендеринга такой же, как и в прошлый раз

```ts

```

```ts

```

#

```ts

```

```ts

```

#

```ts

```

```ts

```

#

```ts

```

```ts

```

#

```ts

```

```ts

```
