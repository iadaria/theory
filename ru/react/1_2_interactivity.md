#

Некоторые элементы на экране обновляются в ответ на ввод пользователя. В React данные, которые изменяются со временем, называются состояние. Вы можете добавить состояние в любой компонент и обновлять его по мере необходимости. В этой главе вы узнаете, как писать компоненты, которые обрабатывают взаимодействия, обновляют свое состояние и отображают различные результаты с течением времени.

React позволяет добавлять обработчики событий в JSX. Обработчики событий - это ваши собственные функции, которые будут запускаться в ответ на действия пользователя, такие как нажатие, наведение курсора, фокусировка на вводе формы и так далее.

*Состояние: память компонента

Компоненты часто нуждаются в изменении того, что отображается на экране в результате взаимодействия.\
Ввод текста в форму должен обновить поле ввода, нажатие кнопки "next" на карусели изображений должно изменить отображаемое изображение, нажатие кнопки "buy" помещает товар в корзину. Компоненты должны "запоминать" вещи: текущее значение ввода, текущее изображение, корзину. В React такая память, специфичная для компонента, называется state..

[Вы можете добавить состояние в компонент с помощью хука useState.\
Он принимает начальное состояние и возвращает пару значений: текущее состояние и функцию-установщик состояния, которая позволяет вам обновить его.]

*Рендеринг и фиксация

Прежде чем ваши компоненты будут отображены на экране, они должны быть отрендерены React.
Этот процесс запроса и подачи пользовательского интерфейса состоит из трех этапов:
1. Триггер рендеринга (доставка заказа посетителя на кухню).
2. Рендеринг компонента (подготовка заказа на кухне)
3. Коммитирование в DOM (размещение заказа на столе)

* Состояние как моментальный снимок

В отличие от обычных переменных JavaScript, состояние в React ведет себя скорее как моментальный снимок. Его установка не изменяет уже имеющуюся переменную state, а вместо этого вызывает повторный рендеринг.\
! Такое поведение поможет вам избежать мелких ошибок. 

[StateFormEx11]
```tsx
console.log(count); // 0
setCount(count + 1); // Request a re-render with 1
console.log(count); // Still 0!
```

[StateCounterEx12]\
Состояние как моментальный снимок объясняет, почему это происходит. Установка состояния запрашивает новый рендеринг, но не изменяет его в уже запущенном коде. Поэтому score продолжает быть 0 сразу после вызова setScore(score + 1).
```tsx
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
```
Можно исправить с помощью: setScore(score + 1) на setScore(s => s + 1). Это позволяет поставить в очередь несколько обновлений состояния.
```tsx
```
```tsx
```
#
```tsx
```
```tsx
```
```tsx
```