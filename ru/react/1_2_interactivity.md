#

Некоторые элементы на экране обновляются в ответ на ввод пользователя. В React данные, которые изменяются со временем, называются состояние. Вы можете добавить состояние в любой компонент и обновлять его по мере необходимости. В этой главе вы узнаете, как писать компоненты, которые обрабатывают взаимодействия, обновляют свое состояние и отображают различные результаты с течением времени.

React позволяет добавлять обработчики событий в JSX. Обработчики событий - это ваши собственные функции, которые будут запускаться в ответ на действия пользователя, такие как нажатие, наведение курсора, фокусировка на вводе формы и так далее.

# Состояние: память компонента

Компоненты часто нуждаются в изменении того, что отображается на экране в результате взаимодействия.\
Ввод текста в форму должен обновить поле ввода, нажатие кнопки "next" на карусели изображений должно изменить отображаемое изображение, нажатие кнопки "buy" помещает товар в корзину. Компоненты должны "запоминать" вещи: текущее значение ввода, текущее изображение, корзину. В React такая память, специфичная для компонента, называется state..

[Вы можете добавить состояние в компонент с помощью хука useState.\
Он принимает начальное состояние и возвращает пару значений: текущее состояние и функцию-установщик состояния, которая позволяет вам обновить его.]

# Рендеринг и фиксация

Прежде чем ваши компоненты будут отображены на экране, они должны быть отрендерены React.
Этот процесс запроса и подачи пользовательского интерфейса состоит из трех этапов:
1. Триггер рендеринга (доставка заказа посетителя на кухню).
2. Рендеринг компонента (подготовка заказа на кухне)
3. Коммитирование в DOM (размещение заказа на столе)

# Состояние как моментальный снимок

В отличие от обычных переменных JavaScript, состояние в React ведет себя скорее как моментальный снимок. Его установка не изменяет уже имеющуюся переменную state, а вместо этого вызывает повторный рендеринг.\
! Такое поведение поможет вам избежать мелких ошибок. 

[StateFormEx11]
```tsx
console.log(count); // 0
setCount(count + 1); // Request a re-render with 1
console.log(count); // Still 0!
```

[StateCounterEx12]\
Состояние как моментальный снимок объясняет, почему это происходит. Установка состояния запрашивает новый рендеринг, но не изменяет его в уже запущенном коде. Поэтому score продолжает быть 0 сразу после вызова setScore(score + 1).
```tsx
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
```
Можно исправить с помощью: setScore(score + 1) на setScore(s => s + 1). *Это позволяет поставить в очередь несколько обновлений состояния.*

```tsx
```
```tsx
```
```tsx
```

# Обновление объектов в состоянии
Если у нас состояние в виде объекта, то мы не должны менять этот объект хранящийся в состоянии напрямую, мы должны создать новый(или сделать копию), а затем обновить состояние с помощью этой копии. Обычно используется оператор расширения(...)
```tsx
  const [person, setPerson] = useState({
        name: 'Niki de Saint Phalle',
        artwork: {
            title: 'Blue Nana',
            city: 'Hamburg',
            image: 'https://i.imgur.com/Sd1AgUOm.jpg',
        },
    });

    function handleNameChange(e) {
        setPerson({
            ...person,
            name: e.target.value,
        });
    }
```
```tsx
```
```tsx
```
```tsx
```
# Обновление массивов в состоянии
Как и с объектами, мы создаем новый массив для обновления состояния, а не изменяем старый, который доступен только для чтения.

# Реакция на события

React позволяет добавлять обработчики событий в JSX. Обработчики событий — это ваши собственные функции, которые будут запускаться в ответ на такие взаимодействия, как нажатие, наведение курсора, фокусировка ввода формы и так далее.

*Добавление обработчика:\
Чтобы добавить обработчик событий, вы сначала определите функцию, а затем передадите ее как параметр в соответствующий JSX тег.
- По традиции, принято называть обработчики событий handle, за которым следует имя события. 
```tsx
export default function Button() {
    // handleClick - обработчик события
    function handleClick() {
        alert('You clicked me!');
    }

    return <button onClick={handleClick}>Click me</button>;
}
```
* Чтение пропсов в обработчиках событий\
Поскольку обработчики событий объявлены внутри компонента, они имеют доступ к пропсам компонента. 
- По соглашению, пропсы обработчиков событий должны начинаться с on, за которым следует заглавная буква.
```tsx
function Button({ onSmash, children }) {
    return <button onClick={onSmash}>{children}</button>;
}

export function App() {
    return (
        <div>
            <Button onSmash={() => alert('Playing!')}>
                Play Movie
            </Button>
        </div>
    );
}
```

* Распространение событий\
Обработчики событий также будут улавливать события от всех дочерних компонентов, которые могут быть у вашего компонента. Мы говорим, что событие "бурлит" или "распространяется" вверх по дереву: оно начинается с того места, где произошло событие, а затем поднимается вверх по дереву.
- Все события распространяются в React, кроме onScroll, которое действует только на тег JSX, к которому вы его прикрепили.

[EventPopingEx13] [Если вы нажмете на любую из кнопок, сначала сработает ее onClick, а затем onClick родительской <div>. Таким образом, появятся два сообщения. Если щелкнуть на самой панели инструментов, то будет запущена только onClick родительской <div>.]

* Остановка распространения\
Обработчики событий получают объект event в качестве единственного аргумента. По традиции он обычно называется e, что означает "событие". Вы можете использовать этот объект для чтения информации о событии.\
Этот объект события также позволяет остановить распространение. Если вы хотите, чтобы событие не достигло родительских компонентов, вам нужно вызвать e.stopPropagation().\
В редких случаях вам может понадобиться перехватить все события на дочерних элементах, даже если они прекратили распространение. Например, вы хотите регистрировать каждый клик в аналитике, независимо от логики распространения. Вы можете сделать это, добавив Capture в конце имени события.
```tsx
/*
Каждое событие распространяется в три фазы:
1. Оно перемещается вниз, вызывая все обработчики onClickCapture.
2. Запускается обработчик onClick щелкнутого элемента.
3. Он перемещается вверх, вызывая все обработчики onClick.

*/
<div
    onClickCapture={() => {
        /* this runs first */
    }}
>
    <button onClick={(e) => e.stopPropagation()} />
    <button onClick={(e) => e.stopPropagation()} />
</div>
```

# Предотвращение поведения по умолчанию

Некоторые события браузера имеют поведение по умолчанию. 
[Например, событие отправки <form>, которое происходит при нажатии на кнопку внутри него, по умолчанию перезагружает всю страницу]\
Можем предотвратить такое поведение вызовом e.preventDefault().
```ts
export default function Signup() {
    return (
        <form onSubmit={(e) => {
            // e.preventDefault();
            alert('Submitting!')
        }}>
            <input />
            <button>Send</button>
        </form>
    );
}
```
Не путаем:
- e.stopPropagation() останавливает срабатывание обработчиков событий, прикрепленных к вышеуказанным тегам.
- e.preventDefault() предотвращает поведение браузера по умолчанию для тех немногих событий, в которых он есть.

! Обработчики событий - лучшее место для побочных эффектов.\
[В отличие от функций рендеринга, обработчики событий не обязаны быть чистыми, поэтому это отличное место для изменения чего-либо - например, изменения значения ввода в ответ на ввод текста или изменения списка в ответ на нажатие кнопки. Однако для того, чтобы изменить какую-то информацию, вам сначала нужно каким-то образом ее сохранить. В React для этого используется state, память компонента.]
```ts
```
# Состояние: память компонента

Компоненты часто должны изменять то, что отображается на экране в результате взаимодействия.\
[нажатие кнопки "buy" должно поместить товар в корзину]

* Когда обычной переменной недостаточно:\

```ts
```
```ts
```
#
```ts
```
```ts
```
#
```ts
```
```ts
```
#
```ts
```
```ts
```
#
```ts
```
```ts
```