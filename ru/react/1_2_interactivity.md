#

Некоторые элементы на экране обновляются в ответ на ввод пользователя. В React данные, которые изменяются со временем, называются состояние. Вы можете добавить состояние в любой компонент и обновлять его по мере необходимости. В этой главе вы узнаете, как писать компоненты, которые обрабатывают взаимодействия, обновляют свое состояние и отображают различные результаты с течением времени.

React позволяет добавлять обработчики событий в JSX. Обработчики событий - это ваши собственные функции, которые будут запускаться в ответ на действия пользователя, такие как нажатие, наведение курсора, фокусировка на вводе формы и так далее.

# Состояние: память компонента

Компоненты часто нуждаются в изменении того, что отображается на экране в результате взаимодействия.\
Ввод текста в форму должен обновить поле ввода, нажатие кнопки "next" на карусели изображений должно изменить отображаемое изображение, нажатие кнопки "buy" помещает товар в корзину. Компоненты должны "запоминать" вещи: текущее значение ввода, текущее изображение, корзину. В React такая память, специфичная для компонента, называется state..

[Вы можете добавить состояние в компонент с помощью хука useState.\
Он принимает начальное состояние и возвращает пару значений: текущее состояние и функцию-установщик состояния, которая позволяет вам обновить его.]

# Рендеринг и фиксация

Прежде чем ваши компоненты будут отображены на экране, они должны быть отрендерены React.
Этот процесс запроса и подачи пользовательского интерфейса состоит из трех этапов:

1. Триггер рендеринга (доставка заказа посетителя на кухню).
2. Рендеринг компонента (подготовка заказа на кухне)
3. Коммитирование в DOM (размещение заказа на столе)

# Состояние как моментальный снимок

В отличие от обычных переменных JavaScript, состояние в React ведет себя скорее как моментальный снимок. Его установка не изменяет уже имеющуюся переменную state, а вместо этого вызывает повторный рендеринг.\
! Такое поведение поможет вам избежать мелких ошибок.

[StateFormEx11]

```tsx
console.log(count); // 0
setCount(count + 1); // Request a re-render with 1
console.log(count); // Still 0!
```

[StateCounterEx12]\
Состояние как моментальный снимок объясняет, почему это происходит. Установка состояния запрашивает новый рендеринг, но не изменяет его в уже запущенном коде. Поэтому score продолжает быть 0 сразу после вызова setScore(score + 1).

```tsx
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score); // 0
```

Можно исправить с помощью: setScore(score + 1) на setScore(s => s + 1). _Это позволяет поставить в очередь несколько обновлений состояния._

```tsx

```

```tsx

```

```tsx

```

# Обновление объектов в состоянии

Если у нас состояние в виде объекта, то мы не должны менять этот объект хранящийся в состоянии напрямую, мы должны создать новый(или сделать копию), а затем обновить состояние с помощью этой копии. Обычно используется оператор расширения(...)

```tsx
const [person, setPerson] = useState({
  name: "Niki de Saint Phalle",
  artwork: {
    title: "Blue Nana",
    city: "Hamburg",
    image: "https://i.imgur.com/Sd1AgUOm.jpg",
  },
});

function handleNameChange(e) {
  setPerson({
    ...person,
    name: e.target.value,
  });
}
```

```tsx

```

```tsx

```

```tsx

```

# Обновление массивов в состоянии

Как и с объектами, мы создаем новый массив для обновления состояния, а не изменяем старый, который доступен только для чтения.

# Реакция на события

React позволяет добавлять обработчики событий в JSX. Обработчики событий — это ваши собственные функции, которые будут запускаться в ответ на такие взаимодействия, как нажатие, наведение курсора, фокусировка ввода формы и так далее.

\*Добавление обработчика:\
Чтобы добавить обработчик событий, вы сначала определите функцию, а затем передадите ее как параметр в соответствующий JSX тег.

- По традиции, принято называть обработчики событий handle, за которым следует имя события.

```tsx
export default function Button() {
  // handleClick - обработчик события
  function handleClick() {
    alert("You clicked me!");
  }

  return <button onClick={handleClick}>Click me</button>;
}
```

- Чтение пропсов в обработчиках событий\
  Поскольку обработчики событий объявлены внутри компонента, они имеют доступ к пропсам компонента.

* По соглашению, пропсы обработчиков событий должны начинаться с on, за которым следует заглавная буква.

```tsx
function Button({ onSmash, children }) {
  return <button onClick={onSmash}>{children}</button>;
}

export function App() {
  return (
    <div>
      <Button onSmash={() => alert("Playing!")}>Play Movie</Button>
    </div>
  );
}
```

- Распространение событий\
  Обработчики событий также будут улавливать события от всех дочерних компонентов, которые могут быть у вашего компонента. Мы говорим, что событие "бурлит" или "распространяется" вверх по дереву: оно начинается с того места, где произошло событие, а затем поднимается вверх по дереву.

* Все события распространяются в React, кроме onScroll, которое действует только на тег JSX, к которому вы его прикрепили.

[EventPopingEx13] [Если вы нажмете на любую из кнопок, сначала сработает ее onClick, а затем onClick родительской <div>. Таким образом, появятся два сообщения. Если щелкнуть на самой панели инструментов, то будет запущена только onClick родительской <div>.]

- Остановка распространения\
  Обработчики событий получают объект event в качестве единственного аргумента. По традиции он обычно называется e, что означает "событие". Вы можете использовать этот объект для чтения информации о событии.\
  Этот объект события также позволяет остановить распространение. Если вы хотите, чтобы событие не достигло родительских компонентов, вам нужно вызвать e.stopPropagation().\
  В редких случаях вам может понадобиться перехватить все события на дочерних элементах, даже если они прекратили распространение. Например, вы хотите регистрировать каждый клик в аналитике, независимо от логики распространения. Вы можете сделать это, добавив Capture в конце имени события.

```tsx
/*
Каждое событие распространяется в три фазы:
1. Оно перемещается вниз, вызывая все обработчики onClickCapture.
2. Запускается обработчик onClick щелкнутого элемента.
3. Он перемещается вверх, вызывая все обработчики onClick.

*/
<div
  onClickCapture={() => {
    /* this runs first */
  }}
>
  <button onClick={(e) => e.stopPropagation()} />
  <button onClick={(e) => e.stopPropagation()} />
</div>
```

# Предотвращение поведения по умолчанию

Некоторые события браузера имеют поведение по умолчанию.
[Например, событие отправки <form>, которое происходит при нажатии на кнопку внутри него, по умолчанию перезагружает всю страницу]\
Можем предотвратить такое поведение вызовом e.preventDefault().

```ts
export default function Signup() {
  return (
    <form
      onSubmit={(e) => {
        // e.preventDefault();
        alert("Submitting!");
      }}
    >
      <input />
      <button>Send</button>
    </form>
  );
}
```

Не путаем:

- e.stopPropagation() останавливает срабатывание обработчиков событий, прикрепленных к вышеуказанным тегам.
- e.preventDefault() предотвращает поведение браузера по умолчанию для тех немногих событий, в которых он есть.

! Обработчики событий - лучшее место для побочных эффектов.\
[В отличие от функций рендеринга, обработчики событий не обязаны быть чистыми, поэтому это отличное место для изменения чего-либо - например, изменения значения ввода в ответ на ввод текста или изменения списка в ответ на нажатие кнопки. Однако для того, чтобы изменить какую-то информацию, вам сначала нужно каким-то образом ее сохранить. В React для этого используется state, память компонента.]

```ts

```

# Состояние: память компонента

Компоненты часто должны изменять то, что отображается на экране в результате взаимодействия.\
[нажатие кнопки "buy" должно поместить товар в корзину]

Когда обычной переменной недостаточно:\
Обработчик события handleClick обновляет локальную переменную index [StateGalleryEx43]. \
Но мы не видим изменения:

_1. Локальные переменные не сохраняются между рендерами._\
[? Когда React рендерит этот компонент во второй раз, он рендерит его с нуля - он не учитывает никаких изменений в локальных переменных.]
_2. Изменения локальных переменных не вызывают рендеринга._

```ts
import { sculptureList } from "./data.js";

export default function Gallery() {
  let index = 0;

  function handleClick() {
    index = index + 1;
  }

  return <>...</>;
}
```

Чтобы обновить компонент новыми данными, должны произойти две вещи:

1. Данные между рендерами должны быть сохранены.\
   [В случае локальной переменной этого не происходит, она сбрасывается [ex43]]
2. _Триггер_ React для рендеринга компонента с новыми данными (повторный рендеринг).
   [В случае изменения локальной переменной он не срабатывает [ex43]]

Хук useState обеспечивает эти две вещи:

- state сохраняется между рендерами;
- функция state setter для обновления переменной запускает повторный рендер компонента;

Синтаксис [ и ] здесь называется деструктуризация массива.

?! Хуки - это специальные функции, которые доступны только во время рендеринга. Они позволяют вам "подключаться" к различным возможностям React.

## Анатомия useState

Когда вы вызываете useState, вы говорите React, что хотите, чтобы этот компонент что-то запомнил:\
[В данном случае вы хотите, чтобы React запомнил index.]

```ts
const [index, setIndex] = useState(0);
```

Единственным аргументом для useState является **инициализирующее значение** вашей переменной состояния.

При каждом рендеринге компонента useState выдает массив, содержащий два значения:

1. Переменная state (index) со значением, которое вы сохранили.
2. Функция установки состояния (setIndex), которая может обновить переменную состояния и вызвать React для повторного рендеринга компонента.

Этот пример не использует React, но он дает представление о том, как useState работает внутри [exHook]

\*Состояние изолированное и частное

_Если вы дважды отобразите один и тот же компонент, каждая копия будет иметь полностью изолированное состояние!_ Изменение одного из них не повлияет на другой.\
В отличие от props, state является полностью приватным для объявляющего его компонента.

Что если вы хотите, чтобы обе галереи синхронизировали свои состояния? Правильный способ сделать это в React - удалить состояние из дочерних компонентов и добавить его в их ближайший общий родительский компонент.

# Render и Commit

Прежде чем ваши компоненты будут отображены на экране, они должны быть отрисованы React.
Этот процесс запроса и подачи пользовательского интерфейса состоит из трех этапов:

1. Триггирование рендеринга
2. Рендеринг компонента
3. Коммитирование в DOM

\* Запуск рендеринга\
Есть две причины для рендеринга компонента:

1. Это начальный рендеринг компонента.
2. Состояние компонента (или одного из его предков) было обновлено.

\* Начальный рендер\
Когда ваше приложение запускается, вам необходимо вызвать начальный рендеринг. Фреймворки и песочницы иногда скрывают этот код, но он выполняется вызовом createRoot с целевым узлом DOM, а затем вызовом его метода render с вашим компонентом:

```ts
import Image from "./Image.js";
import { createRoot } from "react-dom/client";

const root = createRoot(document.getElementById("root"));
root.render(<Image />);
```

\* Рендеринг при обновлении состояния\
После того, как компонент был первоначально отрисован, вы можете инициировать дальнейшие рендеры, обновляя его состояние с помощью функции set. Обновление состояния компонента автоматически ставит его в очередь на рендер.

\* Шаг 2. React рендерит ваши компоненты
После запуска рендеринга React вызывает ваши компоненты, чтобы определить, что отобразить на экране. _"Рендеринг" - это обращение React к вашим компонентам._

- При первом рендере React вызывает корневой компонент.
- При последующих рендерах React будет вызывать функциональный компонент, обновление состояния которого вызвало рендер.

Этот процесс рекурсивен: если обновленный компонент возвращает какой-то другой компонент, React будет рендерить этот компонент следующим, и если этот компонент тоже что-то возвращает, он будет рендерить этот компонент следующим, и так далее. Этот процесс будет продолжаться до тех пор, пока не останется вложенных компонентов и React не будет точно знать, что должно быть отображено на экране.

- Во время первоначального рендеринга React создаст DOM-узлы для тегов <section>, <h1> и трех <img>.
- Во время повторного рендеринга React вычислит, какие из их свойств, если таковые имеются, изменились с момента предыдущего рендеринга. Он ничего не будет делать с этой информацией до следующего шага, фазы фиксации.

! Рендеринг всегда должен быть чистым вычислением:

- Одинаковые параметры, одинаковый результат. При одинаковых параметрах компонент всегда должен возвращать одинаковый JSX.
- Он занимается своими делами. Он не должен изменять никакие объекты или переменные, существовавшие до рендеринга.

\* Шаг 3: React фиксирует изменения в DOM

После рендеринга (вызова) ваших компонентов React изменит DOM.

- Для первоначального рендеринга, React будет использовать appendChild() DOM API для размещения всех созданных им узлов DOM на экране.
- Для повторного рендеринга, React будет применять минимально необходимые операции (вычисляемые во время рендеринга!), чтобы DOM соответствовал последнему выводу рендеринга.

! React изменяет узлы DOM, только если есть разница между рендерами.

[ex0_5_TickClock] Например, вот компонент, который рендерится с различными пропсами, передаваемыми от его родителя каждую секунду. Обратите внимание, как вы можете добавить текст в `<input>`, обновляя его value, но текст не исчезает при повторном рендеринге компонента.\
Это работает, потому что во время последнего шага React только обновляет содержимое `<h2>` с новым time. Он видит, что `<input>` появляется в JSX в том же месте, что и в прошлый раз, поэтому React не трогает `<input>` или его value!

\* Браузерная отрисовка\
После того как рендеринг завершен и React обновил DOM, браузер перерисовывает экран. Хотя этот процесс известен как "браузерный рендеринг", мы будем называть его "рисованием", чтобы избежать путаницы в документации.

! React не трогает DOM, если результат рендеринга такой же, как и в прошлый раз

# Состояние как моментальный снимок

Переменные состояния могут выглядеть как обычные переменные JavaScript, которые можно читать и записывать. Однако состояние ведет себя скорее как _моментальный снимок_. Установка состояния не изменяет уже имеющуюся переменную состояния, а вместо этого вызывает повторный рендеринг.

! Установка состояния запускает рендеринг

Установка состояния запрашивает повторный рендеринг в React. Это означает, что для того, чтобы интерфейс отреагировал на событие, необходимо _обновить состояние_.

[ExRenderForm]
У нас при отправке состояние isSent так и остается false, и функция sendMessage выполняется, потом выполнение функции onSubmit завершается и происходить рендеринг:
Вот что происходит, когда вы нажимаете на кнопку:

1. Выполняется обработчик события onSubmit.
2. setIsSent(true) устанавливает isSent в true и ставит в очередь новый рендер.
3. React повторно рендерит компонент в соответствии с новым значением isSent.

\* Рендеринг делает моментальный снимок времени\

- "Рендеринг" означает, что React вызывает ваш компонент, который является функцией.
- JSX, который вы возвращаете из этой функции, — это как снимок пользовательского интерфейса во времени.
- Его пропсы, обработчики событий и локальные переменные были _рассчитаны используя его состояние на момент рендеринга._

В отличие от фотографии или кадра фильма, возвращаемый вами "снимок" пользовательского интерфейса является интерактивным
.(? 🤔 ну да, мы же можем вводить в поле данные) Он включает в себя логику, например, обработчики событий, которые определяют, что происходит в ответ на входные данные. React обновляет экран в соответствии с этим снимком и подключает обработчики событий. В результате нажатие кнопки вызовет обработчик нажатия из вашего JSX.\
Когда React перерисовывает компонент:

1. React снова вызывает вашу функцию.
2. Ваша функция возвращает новый снимок JSX.
3. Затем React обновляет экран в соответствии с полученным снимком.

Как память компонента, state не похож на обычную переменную, которая исчезает после возвращения вашей функции. Состояние фактически "живет" в самом React - как будто на полке!- вне вашей функции. Когда React вызывает ваш компонент, он дает вам снимок состояния для этого конкретного рендера. Ваш компонент возвращает снимок пользовательского интерфейса со свежим набором пропсов и обработчиков событий в своем JSX, все рассчитано _используя значения состояния из этого рендера!._

- Вы говорите React обновить состояние
- React обновляет значение состояния
- React передает снимок значения состояния в компонент

[exRenderCounter] Обратите внимание, что number увеличивается только один раз за клик!\
_Установка состояния изменяет его только для следующего рендера._

```ts
<button
    onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
    }}
>
    +3
</button>
// Look like
<button
    onClick={() => {
        setNumber(0 + 1);
        setNumber(0 + 1);
        setNumber(0 + 1);
    }}
>
    +3
</button>
```

\* Состояние с течением времени\
[exRenderCounter]
Но что если поставить таймер на оповещение, чтобы оно срабатывало только после того, как компонент перерендерится?

```ts
setNumber(0 + 5);
setTimeout(() => {
  alert(0);
}, 3000);
```

Состояние, хранящееся в React, может измениться к моменту запуска оповещения, но оно было запланировано с использованием снимка состояния на момент взаимодействия пользователя с ним!

_Значение переменной состояния никогда не меняется во время рендеринга_, даже если код обработчика события асинхронный.

Это делает ваши обработчики событий менее подверженными ошибкам синхронизации.

_React сохраняет значения состояния "фиксированными" в обработчиках событий одного рендера._ Вам не нужно беспокоиться о том, изменилось ли состояние во время выполнения кода.

- Установка состояния запрашивает новый рендер.
- React хранит состояние вне вашего компонента
- Когда вы вызываете useState, React дает вам снимок состояния для данного рендера.
- Переменные и обработчики событий не "переживают" повторных рендеров. Каждый рендер имеет свои собственные обработчики событий.
- Каждый рендер (и функции внутри него) всегда будет "видеть" снимок состояния, который React передал этому рендеру.
- Обработчики событий, созданные в прошлом, имеют значения состояния из рендера, в котором они были созданы.

Но что если вы хотите прочитать последнее состояние перед повторным рендерингом?

## Очередь обновлений состояния

Установка переменной состояния ставит в очередь очередной рендеринг. Но иногда вы можете захотеть выполнить несколько операций над значением перед постановкой в очередь следующего рендера. Для этого необходимо понять, как React выполняет _пакетную обработку_ обновлений состояния.

React собирает обновления состояния [exRenderCounter]\
Однако, как вы помните из предыдущего раздела, значения состояния каждого рендера фиксированы, поэтому значение number в обработчике событий первого рендера всегда 0.

```ts
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

Но здесь есть еще один фактор. _React ждет, пока будет выполнен весь код внутри обработчика событий, прежде чем обрабатывать ваши обновления состояния_. Вот почему повторный рендеринг происходит только после всех этих вызовов setNumber().\
Это позволяет вам обновлять несколько переменных состояния - даже из нескольких компонентов - не вызывая слишком много повторных рендеров. Но это также означает, что пользовательский интерфейс не будет обновляться до тех пор, пока не завершится ваш обработчик событий и любой код в нем. Такое поведение, также известное как _батчинг_, заставляет ваше приложение React работать намного быстрее.
_React не выполняет пакетную обработку многочисленных намеренных событий, таких как клики_ - каждый клик обрабатывается отдельно.

\* Обновление одного и того же состояния несколько раз до следующего рендера\

Это редкий случай использования, но если вы хотите обновить одну и ту же переменную состояния несколько раз до следующего рендера, вместо передачи значения следующего состояния, как setNumber(number + 1), вы можете передать функцию, которая вычисляет следующее состояние на основе предыдущего в очереди, как setNumber(n => n + 1). Это способ сказать React "сделать что-то со значением состояния" вместо того, чтобы просто заменить его.

```ts
setNumber((n) => n + 1);
setNumber((n) => n + 1);
setNumber((n) => n + 1);
```

Здесь n => n + 1 называется _функцией обновления_(updater function). Когда вы передаете ее установщику состояния:

1. React ставит эту функцию в очередь на обработку после выполнения всего остального кода в обработчике событий.
2. Во время следующего рендеринга React просматривает очередь и выдает окончательное обновленное состояние.

Вот как React работает через эти строки кода при выполнении обработчика события:

1. setNumber(n => n + 1): n => n + 1 - это функция. React добавляет ее в очередь.
2. setNumber(n => n + 1): n => n + 1 - функция. React добавляет ее в очередь.
3. setNumber(n => n + 1): n => n + 1 - функция. React добавляет ее в очередь.

Когда вы вызываете useState во время следующего рендеринга, React просматривает очередь. Предыдущее состояние number было 0, поэтому именно его React передает первой функции обновления в качестве аргумента n. Затем React берет возвращаемое значение предыдущей функции обновления и передает его следующей функции обновления как n, и так далее.

React сохраняет 3 как конечный результат и возвращает его из useState.

# Вопрос ?

Как насчет этого обработчика событий? Как вы думаете, каким будет number в следующем рендере?

```ts
<button onClick={() => {
    setNumber(number + 5);
    setNumber(n => n + 1);
}}>
// Или
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
  setNumber(42);
}}>
```

- Вы могли заметить, что setState(5) на самом деле работает как setState(n => 5), но n не используется!

Подводя итог, вот как вы можете думать о том, что вы передаете сеттеру состояния setNumber:

- Функция обновления (например, n => n + 1) добавляется в очередь.
- Любое другое значение (например, число 5) добавляет в очередь "заменить на 5", игнорируя то, что уже поставлено в очередь.

После завершения обработчика события React запустит повторный рендеринг. Во время повторного рендеринга React будет обрабатывать очередь. Функции обновления выполняются во время рендеринга, поэтому функции обновления должны быть чистыми и только возвращать результат. Не пытайтесь устанавливать состояние внутри них или запускать другие побочные эффекты. В строгом режиме React будет запускать каждую функцию обновления дважды (но отбрасывать второй результат), чтобы помочь вам найти ошибки.

\* Соглашения об именовании\
[Обычно принято называть аргумент функции обновления по первым буквам соответствующей переменной состояния:]

```ts
setEnabled((e) => !e);
setLastName((ln) => ln.reverse());
setFriendCount((fc) => fc * 2);
```

[Если вы предпочитаете более многословный код, еще одним распространенным способом является повторение полного имени переменной состояния, например setEnabled(enabled => !enabled), или использование префикса, например setEnabled(prevEnabled => !prevEnabled).]

Итого:

- Установка состояния не изменяет переменную в существующем рендере, но запрашивает новый рендер.
- React обрабатывает обновления состояния после завершения работы обработчиков событий. Это называется пакетной обработкой.
- Чтобы обновить состояние несколько раз в одном событии, вы можете использовать функцию обновления setNumber(n => n + 1).

## Обновление объектов в состоянии

```ts
const [position, setPosition] = useState({ x: 0, y: 0 });
position.x = 5;
```

Технически, можно изменить содержимое самого объекта. Это называется _мутацией_.

Однако, хотя объекты в React state технически являются изменяемыми, вы должны относиться к ним как к неизменяемым, как к числам, булевым числам и строкам. Вместо того чтобы изменять их, вы всегда должны заменять их.

_Другими словами, вы должны относиться к любому объекту JavaScript, который вы помещаете в состояние, как к объекту только для чтения._

Обратите внимание, что синтаксис распространения ... является "неглубоким" - он копирует объекты только на один уровень вглубь.

Правильнее сказать не вложенный объект, а свойство объекта указывает на объект.

```ts

```

## Обновление массивов в состоянии

Не используем: push, unshift, pop, shift, splice, arr[i] =, reverse, sort.
Используем: concat, [...arr], filter, slice, map.

```ts

```

```ts

```
