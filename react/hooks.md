# React Hooks
Хуки позволяют функциональным компонентам React иметь состояние (state) и методы жизненного цикла (lifecycle methods) подобно классовым компонентам. Появление хуков привело к тому в настоящее время классовые компоненты в React почти не используются.

# useState
Хук useState() предназначен для управления состоянием компонента. Данная функция возвращает пару геттер/сеттер - значение начального состояния и функцию для обновления этого значения. Функцию имеет следующую сигнатуру: const [value, setValue] = useState(defaultValue).

# useEffect
Хук `useEffect()` предназначен для запуска побочных эффектов (например, выполнение сетевого запроса или добавление обработчика событий) после монтирования и отрисовки компонента. Данная функция принимает колбек и массив зависимостей. Что касается массива зависимостей, то логика следующая:
- массив не указан: эффект запускается при каждом рендеринге
- указан пустой массив: эффект запускается только один раз
- указан массив с элементами: эффект запускается при изменении любого элемента
Очистка эффектов производится посредством возвращения значений из хука.

Функция имеет следующую сигнатуру:
```js
// обработчик
const handler = () => {
  console.log('Случился клик!')
}

useEffect(() => {
  // запуск эффекта
  window.addEventListener('click', handler)

  // очистка эффекта
  return () => {
    window.removeEventListener('click', handler)
  }
  // массив зависимостей
}, [handler])
```

# useLayoutEffect

Хук `useLayoutEffect()` похож на хук `useEffect()`, за исключением того, что он запускает эффект перед отрисовкой компонента. Данный хук предназначен для запуска эффектов, влияющих на внешний вид `DOM`, незаметно для пользователя. Эта функция имеет такую же сигнатуру, что и `useEffect()`. В подавляющем большинстве случаев для запуска побочных эффектов используется `useEffect()`.

# useContext

Хук `useContext()` предназначен для прямой передачи пропов компонентам, находящимся на любом уровне вложенности. Он позволяет избежать так называемого "бурения пропов" (prop drilling), т.е. необходимости последовательной передачи пропов на каждом уровне вложенности.

```js
// Создание контекста
import { createContext } from 'react'

export const ContextName = createContext()

// Передача контекста нижеследюующим компонентам
<ContextName.Provider value={initialValue}>
  <App />
</ContextName.Provider>

// Получение значения контекста
import { useContext } from 'react'
import { ContextName } from './ContextName'

const contextValue = useContext(ContextName)
```
...TODO examples

# useReducer
Хук `useReducer()`, как и хук `useState()`, предназначен для управления состоянием. Он используется при наличии сложной логики управления состоянием или когда следующее состояние зависит от предыдущего. useReducer() принимает редуктор (reducer), обновляющий состояние на основе типа (type) и, опционально, полезной нагрузки (payload) переданной операции (action).
reducer
reducer [rɪˈdjuːsə] преобразователь

Сигнатура редуктора:
```js
const reducer = (state, action) => {
  switch(action.type) {
    case 'actionType':
      return newState // { value: state.value + action.payload }
    default:
      return state
  }
}
...
// использование хука
const [state, dispatch] = useReducer(reducer, initialState, initFn)
```
# useRef
Хук `useRef()` возвращает объект, свойство `current` которого содержит ссылку на узел DOM. Данный хук также может использоваться для сохранения любого мутирующего значения.
Создание хука: `const node = useRef()`.
Добавление ссылки: `<tagName ref={node}></tagName>`.

See example (IntervalRef)

# Concurrent rendering

Concurrent rendering (конкурентный режим) предназначен для более плавной работы приложения на устройстве пользователя. Одна из областей применения —  прерываемый рендеринг. Представьте, что пользователь вводит в строку поиска текст. Событие обновляет состояние компонента, и происходит рендер нового списка результатов. Во время этого процесса залипает ввод: браузер не может обновить введенный в поле текст, т.к. занимается рендером нового списка результатов. Конкурентный режим исправляет это ограничение и делает рендер прерываемым.

С новыми фичами конкурентного рендеринга были добавлены и новые API: переходы состояния (state transition), фичи задержки (Suspense) и новые хуки.

# startTransition
Метод API добавлен для обновления состояния компонента, которое влечет за собой тяжелые вычисления. Например, фильтрация списка. Это позволяет значительно улучшить пользовательский ввод и отклик интерфейса, т.к. помечает тяжелые обновления компонента как «переходы» — transitions.

В API представлено в виде функции startTransition, в которую помещают обновления состояний, являющихся несрочными — non-urgent.
urgent [ˈɜːʤənt] adj срочный


startTransition полезен, если вы хотите сделать пользовательский ввод быстрым, не было фриза UI, а несрочные операции выполнялись на фоне.
```js
import { startTransition } from 'react';

// Срочное (urgent) обновление: отображаем введенный текст
setInputValue(input);

// Помечаем обновления состояний как переходы
startTransition(() => {
  // Переход: фильтрация списка по введенному ключевому слову
  setSearchQuery(input);
});
```

```js
```

```js
```

```js
```
